<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="【转载】Async IO in Python: A Complete Walkthrough" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="Async IO is a concurrent programming design that has received dedicated support in Python, evolving rapidly from Python 3.4 through 3.7, and probably beyond." /><meta property="og:description" content="Async IO is a concurrent programming design that has received dedicated support in Python, evolving rapidly from Python 3.4 through 3.7, and probably beyond." /><link rel="canonical" href="https://blog.hxgpark.com/posts/Repost-Async-IO-in-Python-A-Complete-Walkthrough/" /><meta property="og:url" content="https://blog.hxgpark.com/posts/Repost-Async-IO-in-Python-A-Complete-Walkthrough/" /><meta property="og:site_name" content="SeptemberHX’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-09-12T00:57:57+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="【转载】Async IO in Python: A Complete Walkthrough" /><meta name="twitter:site" content="@September_HX" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-09-12T00:57:57+08:00","datePublished":"2021-09-12T00:57:57+08:00","description":"Async IO is a concurrent programming design that has received dedicated support in Python, evolving rapidly from Python 3.4 through 3.7, and probably beyond.","headline":"【转载】Async IO in Python: A Complete Walkthrough","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.hxgpark.com/posts/Repost-Async-IO-in-Python-A-Complete-Walkthrough/"},"url":"https://blog.hxgpark.com/posts/Repost-Async-IO-in-Python-A-Complete-Walkthrough/"}</script><title>【转载】Async IO in Python: A Complete Walkthrough | SeptemberHX's Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="SeptemberHX's Blog"><meta name="application-name" content="SeptemberHX's Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/avator.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">SeptemberHX's Blog</a></div><div class="site-subtitle font-italic">祝你有个好心情</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/SeptemberHX" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/September_HX" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['september_hx','outlook.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>【转载】Async IO in Python: A Complete Walkthrough</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>【转载】Async IO in Python: A Complete Walkthrough</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1631379477" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2021-09-12 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href="https://github.com/SeptemberHX">SeptemberHX</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="10304 字"> <em>57 分钟</em>阅读</span></div></div></div><div class="post-content"><p>Async IO is a concurrent programming design that has received dedicated support in Python, evolving rapidly from Python 3.4 through 3.7, and <a href="https://twitter.com/1st1/status/1041855365745455104">probably beyond</a>.</p><p>You may be thinking with dread, “Concurrency, parallelism, threading, multiprocessing. That’s a lot to grasp already. Where does async IO fit in?”</p><p>This tutorial is built to help you answer that question, giving you a firmer grasp of Python’s approach to async IO.</p><p><strong>Here’s what you’ll cover:</strong></p><ul><li><strong>Asynchronous IO (async IO)</strong>: a language-agnostic paradigm (model) that has implementations across a host of programming languages<li><strong><code class="language-plaintext highlighter-rouge">async</code>/<code class="language-plaintext highlighter-rouge">await</code></strong>: two new <a href="https://realpython.com/python-keywords/">Python keywords</a> that are used to define coroutines<li><strong><code class="language-plaintext highlighter-rouge">asyncio</code></strong>: the Python package that provides a foundation and API for running and managing coroutines</ul><p>Coroutines (specialized generator functions) are the heart of async IO in Python, and we’ll dive into them later on.</p><blockquote><p><strong>Note</strong>: In this article, I use the term <strong>async IO</strong> to denote the language-agnostic design of asynchronous IO, while <code class="language-plaintext highlighter-rouge">asyncio</code> refers to the Python package.</p></blockquote><p>Before you get started, you’ll need to make sure you’re set up to use <code class="language-plaintext highlighter-rouge">asyncio</code> and other libraries found in this tutorial.</p><h2 id="setting-up-your-environment"><span class="mr-2">Setting Up Your Environment</span><a href="#setting-up-your-environment" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>You’ll need Python 3.7 or above to follow this article in its entirety, as well as the <code class="language-plaintext highlighter-rouge">aiohttp</code> and <code class="language-plaintext highlighter-rouge">aiofiles</code> packages:</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nv">$ </span>python3.7 <span class="nt">-m</span> venv ./py37async
<span class="nv">$ </span><span class="nb">source</span> ./py37async/bin/activate  <span class="c"># Windows: .\py37async\Scripts\activate.bat</span>
<span class="nv">$ </span>pip <span class="nb">install</span> <span class="nt">--upgrade</span> pip aiohttp aiofiles  <span class="c"># Optional: aiodns</span>
</pre></table></code></div></div><p>For help with installing Python 3.7 and setting up a virtual environment, check out <a href="https://realpython.com/installing-python/">Python 3 Installation &amp; Setup Guide</a> or <a href="https://realpython.com/python-virtual-environments-a-primer/">Virtual Environments Primer</a>.</p><p>With that, let’s jump in.</p><h2 id="the-10000-foot-view-of-async-io"><span class="mr-2">The 10,000-Foot View of Async IO</span><a href="#the-10000-foot-view-of-async-io" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Async IO is a bit lesser known than its tried-and-true cousins, multiprocessing and <a href="https://realpython.com/intro-to-python-threading/">threading</a>. This section will give you a fuller picture of what async IO is and how it fits into its surrounding landscape.</p><h3 id="where-does-async-io-fit-in"><span class="mr-2">Where Does Async IO Fit In?</span><a href="#where-does-async-io-fit-in" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Concurrency and parallelism are expansive subjects that are not easy to wade into. While this article focuses on async IO and its implementation in Python, it’s worth taking a minute to compare async IO to its counterparts in order to have context about how async IO fits into the larger, sometimes dizzying puzzle.</p><ul><li><p><strong>Parallelism</strong> consists of performing multiple operations at the same time. <strong>Multiprocessing</strong> is a means to effect parallelism, and it entails spreading tasks over a computer’s central processing units (CPUs, or cores). Multiprocessing is well-suited for CPU-bound tasks: tightly bound <a href="https://realpython.com/python-for-loop/"><code class="language-plaintext highlighter-rouge">for</code> loops</a> and mathematical computations usually fall into this category.</p><li><p><strong>Concurrency</strong> is a slightly broader term than parallelism. It suggests that multiple tasks have the ability to run in an overlapping manner. (There’s a saying that concurrency does not imply parallelism.)</p><li><p><strong>Threading</strong> is a concurrent execution model whereby multiple <a href="https://en.wikipedia.org/wiki/Thread_(computing)">threads</a> take turns executing tasks. One process can contain multiple threads. Python has a complicated relationship with threading thanks to its <a href="https://realpython.com/python-gil/">GIL</a>, but that’s beyond the scope of this article.</p></ul><p>What’s important to know about threading is that it’s better for IO-bound tasks. While a CPU-bound task is characterized by the computer’s cores continually working hard from start to finish, an IO-bound job is dominated by a lot of waiting on input/output to complete.</p><p>To recap the above, concurrency encompasses both multiprocessing (ideal for CPU-bound tasks) and threading (suited for IO-bound tasks). Multiprocessing is a form of parallelism, with parallelism being a specific type (subset) of concurrency. The Python standard library has offered longstanding <a href="https://docs.python.org/3/library/concurrency.html">support for both of these</a> through its <code class="language-plaintext highlighter-rouge">multiprocessing</code>, <code class="language-plaintext highlighter-rouge">threading</code>, and <code class="language-plaintext highlighter-rouge">concurrent.futures</code> packages.</p><p>Now it’s time to bring a new member to the mix. Over the last few years, a separate design has been more comprehensively built into <a href="https://realpython.com/cpython-source-code-guide/">CPython</a>: asynchronous IO, enabled through the standard library’s <code class="language-plaintext highlighter-rouge">asyncio</code> package and the new <code class="language-plaintext highlighter-rouge">async</code> and <code class="language-plaintext highlighter-rouge">await</code> language keywords. To be clear, async IO is not a newly invented concept, and it has existed or is being built into other languages and runtime environments, such as <a href="https://gobyexample.com/goroutines">Go</a>, <a href="https://docs.microsoft.com/en-us/dotnet/csharp/async">C#</a>, or <a href="https://docs.scala-lang.org/sips/async.html">Scala</a>.</p><p>The <code class="language-plaintext highlighter-rouge">asyncio</code> package is billed by the Python documentation as <a href="https://docs.python.org/3/library/asyncio.html">a library to write concurrent code</a>. However, async IO is not threading, nor is it multiprocessing. It is not built on top of either of these.</p><p>In fact, <font color="orange">**async IO is a single-threaded, single-process design**</font>: it uses <strong>cooperative multitasking</strong>, a term that you’ll flesh out by the end of this tutorial. It has been said in other words that async IO gives a feeling of concurrency despite using a single thread in a single process. Coroutines (a central feature of async IO) can be scheduled concurrently, but they are not inherently concurrent.</p><p>To reiterate, async IO is a style of concurrent programming, but it is not parallelism. It’s more closely aligned with threading than with multiprocessing but is very much distinct from both of these and is a standalone member in concurrency’s bag of tricks.</p><p>That leaves one more term. What does it mean for something to be <strong>asynchronous</strong>? This isn’t a rigorous definition, but for our purposes here, I can think of two properties:</p><ul><li>Asynchronous routines are able to “pause” while waiting on their ultimate result and let other routines run in the meantime.<li><a href="https://realpython.com/python-async-features/">Asynchronous code</a>, through the mechanism above, facilitates concurrent execution. To put it differently, asynchronous code gives the look and feel of concurrency.</ul><p>Here’s a diagram to put it all together. The white terms represent concepts, and the green terms represent ways in which they are implemented or effected:</p><p><a href="https://files.realpython.com/media/Screen_Shot_2018-10-17_at_3.18.44_PM.c02792872031.jpg"><img data-src="/assets/img/【转载】Async-IO-in-Python-A-Complete-Walkthrough/Screen_Shot_2018-10-17_at_3.18.44_PM.c02792872031.jpg" alt="Concurrency versus parallelism" data-proofer-ignore></a></p><p>I’ll stop there on the comparisons between concurrent programming models. This tutorial is focused on the subcomponent that is async IO, how to use it, and the <a href="https://realpython.com/python-api/">APIs</a> that have sprung up around it. For a thorough exploration of threading versus multiprocessing versus async IO, pause here and check out Jim Anderson’s <a href="https://realpython.com/python-concurrency/">overview of concurrency in Python</a>. Jim is way funnier than me and has sat in more meetings than me, to boot.</p><h3 id="async-io-explained"><span class="mr-2">Async IO Explained</span><a href="#async-io-explained" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Async IO may at first seem counterintuitive and paradoxical. How does something that facilitates concurrent code use a single thread and a single CPU core? I’ve never been very good at conjuring up examples, so I’d like to paraphrase one from Miguel Grinberg’s 2017 PyCon talk, which explains everything quite beautifully:</p><blockquote><p>Chess master Judit Polgár hosts a chess exhibition in which she plays multiple amateur players. She has two ways of conducting the exhibition: synchronously and asynchronously.</p><p>Assumptions:</p><ul><li>24 opponents<li>Judit makes each chess move in 5 seconds<li>Opponents each take 55 seconds to make a move<li>Games average 30 pair-moves (60 moves total)</ul><p><strong>Synchronous version</strong>: Judit plays one game at a time, never two at the same time, until the game is complete. Each game takes <em>(55 + 5) * 30 == 1800</em> seconds, or 30 minutes. The entire exhibition takes <em>24 * 30 == 720</em> minutes, or <strong>12 hours</strong>.</p><p><strong>Asynchronous version</strong>: Judit moves from table to table, making one move at each table. She leaves the table and lets the opponent make their next move during the wait time. One move on all 24 games takes Judit <em>24 * 5 == 120</em> seconds, or 2 minutes. The entire exhibition is now cut down to <em>120 * 30 == 3600</em> seconds, or just <strong>1 hour</strong>. <a href="https://youtu.be/iG6fr81xHKA?t=4m29s">(Source)</a></p></blockquote><p>There is only one Judit Polgár, who has only two hands and makes only one move at a time by herself. But playing asynchronously cuts the exhibition time down from 12 hours to one. So, cooperative multitasking is a fancy way of saying that a program’s event loop (more on that later) communicates with multiple tasks to let each take turns running at the optimal time.</p><p>Async IO takes long waiting periods in which functions would otherwise be blocking and allows other functions to run during that downtime. (A function that blocks effectively forbids others from running from the time that it starts until the time that it returns.)</p><h3 id="async-io-is-not-easy"><span class="mr-2">Async IO Is Not Easy</span><a href="#async-io-is-not-easy" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>I’ve heard it said, “Use async IO when you can; use threading when you must.” The truth is that building durable multithreaded code can be hard and error-prone. Async IO avoids some of the potential speedbumps that you might otherwise encounter with a threaded design.</p><p>But that’s not to say that async IO in Python is easy. Be warned: when you venture a bit below the surface level, async programming can be difficult too! Python’s async model is built around concepts such as callbacks, events, transports, protocols, and futures—just the terminology can be intimidating. The fact that its API has been changing continually makes it no easier.</p><p>Luckily, <code class="language-plaintext highlighter-rouge">asyncio</code> has matured to a point where most of its features are no longer provisional, while its documentation has received a huge overhaul and some quality resources on the subject are starting to emerge as well.</p><h2 id="the-asyncio-package-and-asyncawait"><span class="mr-2">The <code class="language-plaintext highlighter-rouge"><span class="mr-2">asyncio</code> Package and <code class="language-plaintext highlighter-rouge"><span class="mr-2">async</code>/<code class="language-plaintext highlighter-rouge"><span class="mr-2">await</code></span><a href="#the-asyncio-package-and-asyncawait" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Now that you have some background on async IO as a design, let’s explore Python’s implementation. Python’s <code class="language-plaintext highlighter-rouge">asyncio</code> package (introduced in Python 3.4) and its two keywords, <code class="language-plaintext highlighter-rouge">async</code> and <code class="language-plaintext highlighter-rouge">await</code>, serve different purposes but come together to help you declare, build, execute, and manage asynchronous code.</p><h3 id="the-asyncawait-syntax-and-native-coroutines"><span class="mr-2">The <code class="language-plaintext highlighter-rouge"><span class="mr-2">async</code>/<code class="language-plaintext highlighter-rouge"><span class="mr-2">await</code> Syntax and Native Coroutines</span><a href="#the-asyncawait-syntax-and-native-coroutines" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><blockquote><p><strong>A Word of Caution</strong>: Be careful what you read out there on the Internet. Python’s async IO API has evolved rapidly from Python 3.4 to Python 3.7. Some old patterns are no longer used, and some things that were at first disallowed are now allowed through new introductions.</p></blockquote><p>At the heart of async IO are coroutines. A coroutine is a specialized version of a Python generator function. Let’s start with a baseline definition and then build off of it as you progress here: a coroutine is a function that can suspend its execution before reaching <code class="language-plaintext highlighter-rouge">return</code>, and it can indirectly pass control to another coroutine for some time.</p><p>Later, you’ll dive a lot deeper into how exactly the traditional generator is repurposed into a coroutine. For now, the easiest way to pick up how coroutines work is to start making some.</p><p>Let’s take the immersive approach and write some async IO code. This short program is the <code class="language-plaintext highlighter-rouge">Hello World</code> of async IO but goes a long way towards illustrating its core functionality:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="c1">#!/usr/bin/env python3
# countasync.py
</span>
<span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">count</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"One"</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Two"</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">gather</span><span class="p">(</span><span class="n">count</span><span class="p">(),</span> <span class="n">count</span><span class="p">(),</span> <span class="n">count</span><span class="p">())</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="n">asyncio</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
    <span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">s</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">__file__</span><span class="si">}</span><span class="s"> executed in </span><span class="si">{</span><span class="n">elapsed</span><span class="si">:</span><span class="mf">0.2</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds."</span><span class="p">)</span>
</pre></table></code></div></div><p>When you execute this file, take note of what looks different than if you were to define the functions with just <code class="language-plaintext highlighter-rouge">def</code> and <code class="language-plaintext highlighter-rouge">time.sleep()</code>:</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nv">$ </span>python3 countasync.py
One
One
One
Two
Two
Two
countasync.py executed <span class="k">in </span>1.01 seconds.
</pre></table></code></div></div><p>The order of this output is the heart of async IO. Talking to each of the calls to <code class="language-plaintext highlighter-rouge">count()</code> is a single event loop, or coordinator. When each task reaches <code class="language-plaintext highlighter-rouge">await asyncio.sleep(1)</code>, the function yells up to the event loop and gives control back to it, saying, “I’m going to be sleeping for 1 second. Go ahead and let something else meaningful be done in the meantime.”</p><p>Contrast this to the synchronous version:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="c1">#!/usr/bin/env python3
# countsync.py
</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">count</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"One"</span><span class="p">)</span>
    <span class="n">time</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Two"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">count</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="n">main</span><span class="p">()</span>
    <span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">s</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">__file__</span><span class="si">}</span><span class="s"> executed in </span><span class="si">{</span><span class="n">elapsed</span><span class="si">:</span><span class="mf">0.2</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds."</span><span class="p">)</span>
</pre></table></code></div></div><p>When executed, there is a slight but critical change in order and execution time:</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nv">$ </span>python3 countsync.py
One
Two
One
Two
One
Two
countsync.py executed <span class="k">in </span>3.01 seconds.
</pre></table></code></div></div><p>While using <code class="language-plaintext highlighter-rouge">time.sleep()</code> and <code class="language-plaintext highlighter-rouge">asyncio.sleep()</code> may seem banal, they are used as stand-ins for any time-intensive processes that involve wait time. (The most mundane thing you can wait on is a <code class="language-plaintext highlighter-rouge">sleep()</code> call that does basically nothing.) That is, <code class="language-plaintext highlighter-rouge">time.sleep()</code> can represent any time-consuming blocking function call, while <code class="language-plaintext highlighter-rouge">asyncio.sleep()</code> is used to stand in for a non-blocking call (but one that also takes some time to complete).</p><p>As you’ll see in the next section, the benefit of awaiting something, including <code class="language-plaintext highlighter-rouge">asyncio.sleep()</code>, is that the surrounding function can temporarily cede control to another function that’s more readily able to do something immediately. <font color="green">In contrast, `time.sleep()` or any other blocking call is incompatible with asynchronous Python code, because it will stop everything in its tracks for the duration of the sleep time.</font></p><h3 id="the-rules-of-async-io"><span class="mr-2">The Rules of Async IO</span><a href="#the-rules-of-async-io" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>At this point, a more formal definition of <code class="language-plaintext highlighter-rouge">async</code>, <code class="language-plaintext highlighter-rouge">await</code>, and the coroutine functions that they create are in order. This section is a little dense, but getting a hold of <code class="language-plaintext highlighter-rouge">async</code>/<code class="language-plaintext highlighter-rouge">await</code> is instrumental, so come back to this if you need to:</p><ul><li>The syntax <code class="language-plaintext highlighter-rouge">async def</code> introduces either a <strong>native coroutine</strong> or an <strong>asynchronous generator</strong>. The expressions <code class="language-plaintext highlighter-rouge">async with</code> and <code class="language-plaintext highlighter-rouge">async for</code> are also valid, and you’ll see them later on.<li>The keyword <code class="language-plaintext highlighter-rouge">await</code> passes function control back to the event loop. (It suspends the execution of the surrounding coroutine.) If Python encounters an <code class="language-plaintext highlighter-rouge">await f()</code> expression in the scope of <code class="language-plaintext highlighter-rouge">g()</code>, this is how <code class="language-plaintext highlighter-rouge">await</code> tells the event loop, “Suspend execution of <code class="language-plaintext highlighter-rouge">g()</code> until whatever I’m waiting on—the result of <code class="language-plaintext highlighter-rouge">f()</code>—is returned. In the meantime, go let something else run.”</ul><p>In code, that second bullet point looks roughly like this:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">async</span> <span class="k">def</span> <span class="nf">g</span><span class="p">():</span>
    <span class="c1"># Pause here and come back to g() when f() is ready
</span>    <span class="n">r</span> <span class="o">=</span> <span class="k">await</span> <span class="n">f</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">r</span>
</pre></table></code></div></div><p>There’s also a strict set of rules around when and how you can and cannot use <code class="language-plaintext highlighter-rouge">async</code>/<code class="language-plaintext highlighter-rouge">await</code>. These can be handy whether you are still picking up the syntax or already have exposure to using <code class="language-plaintext highlighter-rouge">async</code>/<code class="language-plaintext highlighter-rouge">await</code>:</p><ul><li>A function that you introduce with <code class="language-plaintext highlighter-rouge">async def</code> is a coroutine. It may use <code class="language-plaintext highlighter-rouge">await</code>, <code class="language-plaintext highlighter-rouge">return</code>, or <code class="language-plaintext highlighter-rouge">yield</code>, but all of these are optional. Declaring <code class="language-plaintext highlighter-rouge">async def noop(): pass</code> is valid:<ul><li>Using <code class="language-plaintext highlighter-rouge">await</code> and/or <code class="language-plaintext highlighter-rouge">return</code> creates a coroutine function. To call a coroutine function, you must <code class="language-plaintext highlighter-rouge">await</code> it to get its results.<li>It is less common (and only recently legal in Python) to use <code class="language-plaintext highlighter-rouge">yield</code> in an <code class="language-plaintext highlighter-rouge">async def</code> block. This creates an <a href="https://www.python.org/dev/peps/pep-0525/">asynchronous generator</a>, which you iterate over with <code class="language-plaintext highlighter-rouge">async for</code>. Forget about async generators for the time being and focus on getting down the syntax for coroutine functions, which use <code class="language-plaintext highlighter-rouge">await</code> and/or <code class="language-plaintext highlighter-rouge">return</code>.<li>Anything defined with <code class="language-plaintext highlighter-rouge">async def</code> may not use <code class="language-plaintext highlighter-rouge">yield from</code>, which will raise a <a href="https://realpython.com/invalid-syntax-python/"><code class="language-plaintext highlighter-rouge">SyntaxError</code></a>.</ul><li>Just like it’s a <code class="language-plaintext highlighter-rouge">SyntaxError</code> to use <code class="language-plaintext highlighter-rouge">yield</code> outside of a <code class="language-plaintext highlighter-rouge">def</code> function, it is a <code class="language-plaintext highlighter-rouge">SyntaxError</code> to use <code class="language-plaintext highlighter-rouge">await</code> outside of an <code class="language-plaintext highlighter-rouge">async def</code> coroutine. You can only use <code class="language-plaintext highlighter-rouge">await</code> in the body of coroutines.</ul><p>Here are some terse examples meant to summarize the above few rules:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">async</span> <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">y</span> <span class="o">=</span> <span class="k">await</span> <span class="n">z</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># OK - `await` and `return` allowed in coroutines
</span>    <span class="k">return</span> <span class="n">y</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">yield</span> <span class="n">x</span>  <span class="c1"># OK - this is an async generator
</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">m</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">yield</span> <span class="k">from</span> <span class="n">gen</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># No - SyntaxError
</span>
<span class="k">def</span> <span class="nf">m</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">y</span> <span class="o">=</span> <span class="k">await</span> <span class="n">z</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Still no - SyntaxError (no `async def` here)
</span>    <span class="k">return</span> <span class="n">y</span>
</pre></table></code></div></div><p>Finally, when you use <code class="language-plaintext highlighter-rouge">await f()</code>, it’s required that <code class="language-plaintext highlighter-rouge">f()</code> be an object that is <a href="https://docs.python.org/3/reference/datamodel.html#awaitable-objects">awaitable</a>. Well, that’s not very helpful, is it? For now, just know that an awaitable object is either (1) another coroutine or (2) an object defining an <code class="language-plaintext highlighter-rouge">.__await__()</code> dunder method that returns an iterator. If you’re writing a program, for the large majority of purposes, you should only need to worry about case #1.</p><p>That brings us to one more technical distinction that you may see pop up: an older way of marking a function as a coroutine is to decorate a normal <code class="language-plaintext highlighter-rouge">def</code> function with <code class="language-plaintext highlighter-rouge">@asyncio.coroutine</code>. The result is a <strong>generator-based coroutine</strong>. This construction has been outdated since the <code class="language-plaintext highlighter-rouge">async</code>/<code class="language-plaintext highlighter-rouge">await</code> syntax was put in place in Python 3.5.</p><p>These two coroutines are essentially equivalent (both are awaitable), but the first is <strong>generator-based</strong>, while the second is a <strong>native coroutine</strong>:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="o">@</span><span class="n">asyncio</span><span class="p">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">py34_coro</span><span class="p">():</span>
    <span class="s">"""Generator-based coroutine, older syntax"""</span>
    <span class="k">yield</span> <span class="k">from</span> <span class="n">stuff</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">py35_coro</span><span class="p">():</span>
    <span class="s">"""Native coroutine, modern syntax"""</span>
    <span class="k">await</span> <span class="n">stuff</span><span class="p">()</span>
</pre></table></code></div></div><p>If you’re writing any code yourself, prefer native coroutines for the sake of being explicit rather than implicit. Generator-based coroutines will be <a href="https://docs.python.org/3/library/asyncio-task.html#generator-based-coroutines">removed</a> in Python 3.10.</p><p>Towards the latter half of this tutorial, we’ll touch on generator-based coroutines for explanation’s sake only. The reason that <code class="language-plaintext highlighter-rouge">async</code>/<code class="language-plaintext highlighter-rouge">await</code> were introduced is to make coroutines a standalone feature of Python that can be easily differentiated from a normal generator function, thus reducing ambiguity.</p><p>Don’t get bogged down in generator-based coroutines, which have been <a href="https://www.python.org/dev/peps/pep-0492/#rationale-and-goals">deliberately outdated</a> by <code class="language-plaintext highlighter-rouge">async</code>/<code class="language-plaintext highlighter-rouge">await</code>. They have their own small set of rules (for instance, <code class="language-plaintext highlighter-rouge">await</code> cannot be used in a generator-based coroutine) that are largely irrelevant if you stick to the <code class="language-plaintext highlighter-rouge">async</code>/<code class="language-plaintext highlighter-rouge">await</code> syntax.</p><p>Without further ado, let’s take on a few more involved examples.</p><p>Here’s one example of how async IO cuts down on wait time: given a coroutine <code class="language-plaintext highlighter-rouge">makerandom()</code> that keeps producing random integers in the range [0, 10], until one of them exceeds a threshold, you want to let multiple calls of this coroutine not need to wait for each other to complete in succession. You can largely follow the patterns from the two scripts above, with slight changes:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="c1">#!/usr/bin/env python3
# rand.py
</span>
<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="c1"># ANSI colors
</span><span class="n">c</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s">"</span><span class="se">\033</span><span class="s">[0m"</span><span class="p">,</span>   <span class="c1"># End of color
</span>    <span class="s">"</span><span class="se">\033</span><span class="s">[36m"</span><span class="p">,</span>  <span class="c1"># Cyan
</span>    <span class="s">"</span><span class="se">\033</span><span class="s">[91m"</span><span class="p">,</span>  <span class="c1"># Red
</span>    <span class="s">"</span><span class="se">\033</span><span class="s">[35m"</span><span class="p">,</span>  <span class="c1"># Magenta
</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">makerandom</span><span class="p">(</span><span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">6</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="sa">f</span><span class="s">"Initiated makerandom(</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s">)."</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="sa">f</span><span class="s">"makerandom(</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s">) == </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s"> too low; retrying."</span><span class="p">)</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="sa">f</span><span class="s">"---&gt; Finished: makerandom(</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s">) == </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s">"</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">i</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">res</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">makerandom</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">10</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">res</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">444</span><span class="p">)</span>
    <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span> <span class="o">=</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
    <span class="k">print</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"r1: </span><span class="si">{</span><span class="n">r1</span><span class="si">}</span><span class="s">, r2: </span><span class="si">{</span><span class="n">r2</span><span class="si">}</span><span class="s">, r3: </span><span class="si">{</span><span class="n">r3</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</pre></table></code></div></div><p>The colorized output says a lot more than I can and gives you a sense for how this script is carried out:</p><p><a href="https://files.realpython.com/media/asyncio-rand.dffdd83b4256.gif"><img data-src="/assets/img/【转载】Async-IO-in-Python-A-Complete-Walkthrough/asyncio-rand.dffdd83b4256.gif" alt="rand.py program execution" data-proofer-ignore></a></p><p>This program uses one main coroutine, <code class="language-plaintext highlighter-rouge">makerandom()</code>, and runs it concurrently across 3 different inputs. Most programs will contain small, modular coroutines and one wrapper function that serves to chain each of the smaller coroutines together. <a href="https://realpython.com/python-main-function/"><code class="language-plaintext highlighter-rouge">main()</code></a> is then used to gather tasks (futures) by mapping the central coroutine across some iterable or pool.</p><p>In this miniature example, the pool is <code class="language-plaintext highlighter-rouge">range(3)</code>. In a fuller example presented later, it is a set of URLs that need to be requested, parsed, and processed concurrently, and <code class="language-plaintext highlighter-rouge">main()</code> encapsulates that entire routine for each URL.</p><p>While “making random integers” (which is CPU-bound more than anything) is maybe not the greatest choice as a candidate for <code class="language-plaintext highlighter-rouge">asyncio</code>, it’s the presence of <code class="language-plaintext highlighter-rouge">asyncio.sleep()</code> in the example that is designed to mimic an IO-bound process where there is uncertain wait time involved. For example, the <code class="language-plaintext highlighter-rouge">asyncio.sleep()</code> call might represent sending and receiving not-so-random integers between two clients in a message application.</p><h2 id="async-io-design-patterns"><span class="mr-2">Async IO Design Patterns</span><a href="#async-io-design-patterns" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Async IO comes with its own set of possible script designs, which you’ll get introduced to in this section.</p><h3 id="chaining-coroutines"><span class="mr-2">Chaining Coroutines</span><a href="#chaining-coroutines" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>A key feature of coroutines is that they can be chained together. (Remember, a coroutine object is awaitable, so another coroutine can <code class="language-plaintext highlighter-rouge">await</code> it.) This allows you to break programs into smaller, manageable, recyclable coroutines:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="c1">#!/usr/bin/env python3
# chained.py
</span>
<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">part1</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"part1(</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s">) sleeping for </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s"> seconds."</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="sa">f</span><span class="s">"result</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s">-1"</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Returning part1(</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s">) == </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s">."</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">part2</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">arg</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"part2</span><span class="si">{</span><span class="n">n</span><span class="p">,</span> <span class="n">arg</span><span class="si">}</span><span class="s"> sleeping for </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s"> seconds."</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="sa">f</span><span class="s">"result</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s">-2 derived from </span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s">"</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Returning part2</span><span class="si">{</span><span class="n">n</span><span class="p">,</span> <span class="n">arg</span><span class="si">}</span><span class="s"> == </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s">."</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">chain</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="k">await</span> <span class="n">part1</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="k">await</span> <span class="n">part2</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p1</span><span class="p">)</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"--&gt;Chained result</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s"> =&gt; </span><span class="si">{</span><span class="n">p2</span><span class="si">}</span><span class="s"> (took </span><span class="si">{</span><span class="n">end</span><span class="si">:</span><span class="mf">0.2</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds)."</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">args</span><span class="p">))</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">444</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="n">asyncio</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Program finished in </span><span class="si">{</span><span class="n">end</span><span class="si">:</span><span class="mf">0.2</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds."</span><span class="p">)</span>
</pre></table></code></div></div><p>Pay careful attention to the output, where <code class="language-plaintext highlighter-rouge">part1()</code> sleeps for a variable amount of time, and <code class="language-plaintext highlighter-rouge">part2()</code> begins working with the results as they become available:</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="nv">$ </span>python3 chained.py 9 6 3
part1<span class="o">(</span>9<span class="o">)</span> sleeping <span class="k">for </span>4 seconds.
part1<span class="o">(</span>6<span class="o">)</span> sleeping <span class="k">for </span>4 seconds.
part1<span class="o">(</span>3<span class="o">)</span> sleeping <span class="k">for </span>0 seconds.
Returning part1<span class="o">(</span>3<span class="o">)</span> <span class="o">==</span> result3-1.
part2<span class="o">(</span>3, <span class="s1">'result3-1'</span><span class="o">)</span> sleeping <span class="k">for </span>4 seconds.
Returning part1<span class="o">(</span>9<span class="o">)</span> <span class="o">==</span> result9-1.
part2<span class="o">(</span>9, <span class="s1">'result9-1'</span><span class="o">)</span> sleeping <span class="k">for </span>7 seconds.
Returning part1<span class="o">(</span>6<span class="o">)</span> <span class="o">==</span> result6-1.
part2<span class="o">(</span>6, <span class="s1">'result6-1'</span><span class="o">)</span> sleeping <span class="k">for </span>4 seconds.
Returning part2<span class="o">(</span>3, <span class="s1">'result3-1'</span><span class="o">)</span> <span class="o">==</span> result3-2 derived from result3-1.
<span class="nt">--</span><span class="o">&gt;</span>Chained result3 <span class="o">=&gt;</span> result3-2 derived from result3-1 <span class="o">(</span>took 4.00 seconds<span class="o">)</span><span class="nb">.</span>
Returning part2<span class="o">(</span>6, <span class="s1">'result6-1'</span><span class="o">)</span> <span class="o">==</span> result6-2 derived from result6-1.
<span class="nt">--</span><span class="o">&gt;</span>Chained result6 <span class="o">=&gt;</span> result6-2 derived from result6-1 <span class="o">(</span>took 8.01 seconds<span class="o">)</span><span class="nb">.</span>
Returning part2<span class="o">(</span>9, <span class="s1">'result9-1'</span><span class="o">)</span> <span class="o">==</span> result9-2 derived from result9-1.
<span class="nt">--</span><span class="o">&gt;</span>Chained result9 <span class="o">=&gt;</span> result9-2 derived from result9-1 <span class="o">(</span>took 11.01 seconds<span class="o">)</span><span class="nb">.</span>
Program finished <span class="k">in </span>11.01 seconds.
</pre></table></code></div></div><p>In this setup, the runtime of <code class="language-plaintext highlighter-rouge">main()</code> will be equal to the maximum runtime of the tasks that it gathers together and schedules.</p><h3 id="using-a-queue"><span class="mr-2">Using a Queue</span><a href="#using-a-queue" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The <code class="language-plaintext highlighter-rouge">asyncio</code> package provides <a href="https://docs.python.org/3/library/asyncio-queue.html">queue classes</a> that are designed to be similar to classes of the <a href="https://docs.python.org/3/library/queue.html#module-queue"><code class="language-plaintext highlighter-rouge">queue</code></a> module. In our examples so far, we haven’t really had a need for a queue structure. In <code class="language-plaintext highlighter-rouge">chained.py</code>, each task (future) is composed of a set of coroutines that explicitly await each other and pass through a single input per chain.</p><p>There is an alternative structure that can also work with async IO: a number of producers, which are not associated with each other, add items to a queue. Each producer may add multiple items to the queue at staggered, random, unannounced times. A group of consumers pull items from the queue as they show up, greedily and without waiting for any other signal.</p><p>In this design, there is no chaining of any individual consumer to a producer. The consumers don’t know the number of producers, or even the cumulative number of items that will be added to the queue, in advance.</p><p>It takes an individual producer or consumer a variable amount of time to put and extract items from the queue, respectively. The queue serves as a throughput that can communicate with the producers and consumers without them talking to each other directly.</p><blockquote><p><strong>Note</strong>: While queues are often used in threaded programs because of the thread-safety of <code class="language-plaintext highlighter-rouge">queue.Queue()</code>, you shouldn’t need to concern yourself with thread safety when it comes to async IO. (The exception is when you’re combining the two, but that isn’t done in this tutorial.)</p><p>One use-case for queues (as is the case here) is for the queue to act as a transmitter for producers and consumers that aren’t otherwise directly chained or associated with each other.</p></blockquote><p>The synchronous version of this program would look pretty dismal: a group of blocking producers serially add items to the queue, one producer at a time. Only after all producers are done can the queue be processed, by one consumer at a time processing item-by-item. There is a ton of latency in this design. Items may sit idly in the queue rather than be picked up and processed immediately.</p><p>An asynchronous version, <code class="language-plaintext highlighter-rouge">asyncq.py</code>, is below. The challenging part of this workflow is that there needs to be a signal to the consumers that production is done. Otherwise, <code class="language-plaintext highlighter-rouge">await q.get()</code> will hang indefinitely, because the queue will have been fully processed, but consumers won’t have any idea that production is complete.</p><p>(Big thanks for some help from a StackOverflow <a href="https://stackoverflow.com/a/52615705/7954504">user</a> for helping to straighten out <code class="language-plaintext highlighter-rouge">main()</code>: the key is to <code class="language-plaintext highlighter-rouge">await q.join()</code>, which blocks until all items in the queue have been received and processed, and then to cancel the consumer tasks, which would otherwise hang up and wait endlessly for additional queue items to appear.)</p><p>Here is the full script:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre><td class="rouge-code"><pre><span class="c1">#!/usr/bin/env python3
# asyncq.py
</span>
<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="n">it</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">makeitem</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">os</span><span class="p">.</span><span class="n">urandom</span><span class="p">(</span><span class="n">size</span><span class="p">).</span><span class="nb">hex</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">randsleep</span><span class="p">(</span><span class="n">caller</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">caller</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">caller</span><span class="si">}</span><span class="s"> sleeping for </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s"> seconds."</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">produce</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">Queue</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">it</span><span class="p">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>  <span class="c1"># Synchronous loop for each single producer
</span>        <span class="k">await</span> <span class="n">randsleep</span><span class="p">(</span><span class="n">caller</span><span class="o">=</span><span class="sa">f</span><span class="s">"Producer </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="k">await</span> <span class="n">makeitem</span><span class="p">()</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="k">await</span> <span class="n">q</span><span class="p">.</span><span class="n">put</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Producer </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s"> added &lt;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s">&gt; to queue."</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">consume</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">Queue</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">randsleep</span><span class="p">(</span><span class="n">caller</span><span class="o">=</span><span class="sa">f</span><span class="s">"Consumer </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="k">await</span> <span class="n">q</span><span class="p">.</span><span class="n">get</span><span class="p">()</span>
        <span class="n">now</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Consumer </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s"> got element &lt;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s">&gt;"</span>
              <span class="sa">f</span><span class="s">" in </span><span class="si">{</span><span class="n">now</span><span class="o">-</span><span class="n">t</span><span class="si">:</span><span class="mf">0.5</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds."</span><span class="p">)</span>
        <span class="n">q</span><span class="p">.</span><span class="n">task_done</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">nprod</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ncon</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">Queue</span><span class="p">()</span>
    <span class="n">producers</span> <span class="o">=</span> <span class="p">[</span><span class="n">asyncio</span><span class="p">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">produce</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nprod</span><span class="p">)]</span>
    <span class="n">consumers</span> <span class="o">=</span> <span class="p">[</span><span class="n">asyncio</span><span class="p">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">consume</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncon</span><span class="p">)]</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">producers</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">q</span><span class="p">.</span><span class="n">join</span><span class="p">()</span>  <span class="c1"># Implicitly awaits consumers, too
</span>    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">consumers</span><span class="p">:</span>
        <span class="n">c</span><span class="p">.</span><span class="n">cancel</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">argparse</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">444</span><span class="p">)</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="p">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">"-p"</span><span class="p">,</span> <span class="s">"--nprod"</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">"-c"</span><span class="p">,</span> <span class="s">"--ncon"</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">ns</span> <span class="o">=</span> <span class="n">parser</span><span class="p">.</span><span class="n">parse_args</span><span class="p">()</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="n">asyncio</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="o">**</span><span class="n">ns</span><span class="p">.</span><span class="n">__dict__</span><span class="p">))</span>
    <span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Program completed in </span><span class="si">{</span><span class="n">elapsed</span><span class="si">:</span><span class="mf">0.5</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds."</span><span class="p">)</span>
</pre></table></code></div></div><p>The first few coroutines are helper functions that return a random string, a fractional-second performance counter, and a random integer. A producer puts anywhere from 1 to 5 items into the queue. Each item is a tuple of <code class="language-plaintext highlighter-rouge">(i, t)</code> where <code class="language-plaintext highlighter-rouge">i</code> is a random string and <code class="language-plaintext highlighter-rouge">t</code> is the time at which the producer attempts to put the tuple into the queue.</p><p>When a consumer pulls an item out, it simply calculates the elapsed time that the item sat in the queue using the timestamp that the item was put in with.</p><p>Keep in mind that <code class="language-plaintext highlighter-rouge">asyncio.sleep()</code> is used to mimic some other, more complex coroutine that would eat up time and block all other execution if it were a regular blocking function.</p><p>Here is a test run with two producers and five consumers:</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="nv">$ </span>python3 asyncq.py <span class="nt">-p</span> 2 <span class="nt">-c</span> 5
Producer 0 sleeping <span class="k">for </span>3 seconds.
Producer 1 sleeping <span class="k">for </span>3 seconds.
Consumer 0 sleeping <span class="k">for </span>4 seconds.
Consumer 1 sleeping <span class="k">for </span>3 seconds.
Consumer 2 sleeping <span class="k">for </span>3 seconds.
Consumer 3 sleeping <span class="k">for </span>5 seconds.
Consumer 4 sleeping <span class="k">for </span>4 seconds.
Producer 0 added &lt;377b1e8f82&gt; to queue.
Producer 0 sleeping <span class="k">for </span>5 seconds.
Producer 1 added &lt;413b8802f8&gt; to queue.
Consumer 1 got element &lt;377b1e8f82&gt; <span class="k">in </span>0.00013 seconds.
Consumer 1 sleeping <span class="k">for </span>3 seconds.
Consumer 2 got element &lt;413b8802f8&gt; <span class="k">in </span>0.00009 seconds.
Consumer 2 sleeping <span class="k">for </span>4 seconds.
Producer 0 added &lt;06c055b3ab&gt; to queue.
Producer 0 sleeping <span class="k">for </span>1 seconds.
Consumer 0 got element &lt;06c055b3ab&gt; <span class="k">in </span>0.00021 seconds.
Consumer 0 sleeping <span class="k">for </span>4 seconds.
Producer 0 added &lt;17a8613276&gt; to queue.
Consumer 4 got element &lt;17a8613276&gt; <span class="k">in </span>0.00022 seconds.
Consumer 4 sleeping <span class="k">for </span>5 seconds.
Program completed <span class="k">in </span>9.00954 seconds.
</pre></table></code></div></div><p>In this case, the items process in fractions of a second. A delay can be due to two reasons:</p><ul><li>Standard, largely unavoidable overhead<li>Situations where all consumers are sleeping when an item appears in the queue</ul><p>With regards to the second reason, luckily, it is perfectly normal to scale to hundreds or thousands of consumers. You should have no problem with <code class="language-plaintext highlighter-rouge">python3 asyncq.py -p 5 -c 100</code>. The point here is that, theoretically, you could have different users on different systems controlling the management of producers and consumers, with the queue serving as the central throughput.</p><p>So far, you’ve been thrown right into the fire and seen three related examples of <code class="language-plaintext highlighter-rouge">asyncio</code> calling coroutines defined with <code class="language-plaintext highlighter-rouge">async</code> and <code class="language-plaintext highlighter-rouge">await</code>. If you’re not completely following or just want to get deeper into the mechanics of how modern coroutines came to be in Python, you’ll start from square one with the next section.</p><h2 id="async-ios-roots-in-generators"><span class="mr-2">Async IO’s Roots in Generators</span><a href="#async-ios-roots-in-generators" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Earlier, you saw an example of the old-style generator-based coroutines, which have been outdated by more explicit native coroutines. The example is worth re-showing with a small tweak:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="o">@</span><span class="n">asyncio</span><span class="p">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">py34_coro</span><span class="p">():</span>
    <span class="s">"""Generator-based coroutine"""</span>
    <span class="c1"># No need to build these yourself, but be aware of what they are
</span>    <span class="n">s</span> <span class="o">=</span> <span class="k">yield</span> <span class="k">from</span> <span class="n">stuff</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">s</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">py35_coro</span><span class="p">():</span>
    <span class="s">"""Native coroutine, modern syntax"""</span>
    <span class="n">s</span> <span class="o">=</span> <span class="k">await</span> <span class="n">stuff</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">s</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">stuff</span><span class="p">():</span>
    <span class="k">return</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x30</span>
</pre></table></code></div></div><p>As an experiment, what happens if you call <code class="language-plaintext highlighter-rouge">py34_coro()</code> or <code class="language-plaintext highlighter-rouge">py35_coro()</code> on its own, without <code class="language-plaintext highlighter-rouge">await</code>, or without any calls to <code class="language-plaintext highlighter-rouge">asyncio.run()</code> or other <code class="language-plaintext highlighter-rouge">asyncio</code> “porcelain” functions? Calling a coroutine in isolation returns a coroutine object:</p><pre><code class="language-idl">&gt;&gt;&gt; py35_coro()
&lt;coroutine object py35_coro at 0x10126dcc8&gt;
</code></pre><p>This isn’t very interesting on its surface. The result of calling a coroutine on its own is an awaitable <strong>coroutine object</strong>.</p><p>Time for a quiz: what other feature of Python looks like this? (What feature of Python doesn’t actually “do much” when it’s called on its own?)</p><p>Hopefully you’re thinking of <strong>generators</strong> as an answer to this question, because coroutines are enhanced generators under the hood. The behavior is similar in this regard:</p><pre><code class="language-idl">&gt;&gt;&gt; def gen():
...     yield 0x10, 0x20, 0x30
...
&gt;&gt;&gt; g = gen()
&gt;&gt;&gt; g  # Nothing much happens - need to iterate with `.__next__()`
&lt;generator object gen at 0x1012705e8&gt;
&gt;&gt;&gt; next(g)
(16, 32, 48)
</code></pre><p>Generator functions are, as it so happens, the foundation of async IO (regardless of whether you declare coroutines with <code class="language-plaintext highlighter-rouge">async def</code> rather than the older <code class="language-plaintext highlighter-rouge">@asyncio.coroutine</code> wrapper). Technically, <code class="language-plaintext highlighter-rouge">await</code> is more closely analogous to <code class="language-plaintext highlighter-rouge">yield from</code> than it is to <code class="language-plaintext highlighter-rouge">yield</code>. (But remember that <code class="language-plaintext highlighter-rouge">yield from x()</code> is just syntactic sugar to replace <code class="language-plaintext highlighter-rouge">for i in x(): yield i</code>.)</p><p>One critical feature of generators as it pertains to async IO is that they can effectively be stopped and restarted at will. For example, you can <code class="language-plaintext highlighter-rouge">break</code> out of iterating over a generator object and then resume iteration on the remaining values later. When a <a href="https://realpython.com/introduction-to-python-generators/">generator function reaches <code class="language-plaintext highlighter-rouge">yield</code></a>, it yields that value, but then it sits idle until it is told to yield its subsequent value.</p><p>This can be fleshed out through an example:</p><pre><code class="language-idl">&gt;&gt;&gt; from itertools import cycle
&gt;&gt;&gt; def endless():
...     """Yields 9, 8, 7, 6, 9, 8, 7, 6, ... forever"""
...     yield from cycle((9, 8, 7, 6))

&gt;&gt;&gt; e = endless()
&gt;&gt;&gt; total = 0
&gt;&gt;&gt; for i in e:
...     if total &lt; 30:
...         print(i, end=" ")
...         total += i
...     else:
...         print()
...         # Pause execution. We can resume later.
...         break
9 8 7 6 9 8 7 6 9 8 7 6 9 8

&gt;&gt;&gt; # Resume
&gt;&gt;&gt; next(e), next(e), next(e)
(6, 9, 8)
</code></pre><p>The <code class="language-plaintext highlighter-rouge">await</code> keyword behaves similarly, marking a break point at which the coroutine suspends itself and lets other coroutines work. “Suspended,” in this case, means a coroutine that has temporarily ceded control but not totally exited or finished. Keep in mind that <code class="language-plaintext highlighter-rouge">yield</code>, and by extension <code class="language-plaintext highlighter-rouge">yield from</code> and <code class="language-plaintext highlighter-rouge">await</code>, mark a break point in a generator’s execution.</p><p>This is the fundamental difference between functions and generators. A function is all-or-nothing. Once it starts, it won’t stop until it hits a <code class="language-plaintext highlighter-rouge">return</code>, then pushes that value to the caller (the function that calls it). A generator, on the other hand, pauses each time it hits a <code class="language-plaintext highlighter-rouge">yield</code> and goes no further. Not only can it push this value to calling stack, but it can keep a hold of its local variables when you resume it by calling <code class="language-plaintext highlighter-rouge">next()</code> on it.</p><p>There’s a second and lesser-known feature of generators that also matters. You can send a value into a generator as well through its <code class="language-plaintext highlighter-rouge">.send()</code> method. This allows generators (and coroutines) to call (<code class="language-plaintext highlighter-rouge">await</code>) each other without blocking. I won’t get any further into the nuts and bolts of this feature, because it matters mainly for the implementation of coroutines behind the scenes, but you shouldn’t ever really need to use it directly yourself.</p><p>If you’re interested in exploring more, you can start at <a href="https://www.python.org/dev/peps/pep-0342/">PEP 342</a>, where coroutines were formally introduced. Brett Cannon’s <a href="https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/">How the Heck Does Async-Await Work in Python</a> is also a good read, as is the <a href="https://pymotw.com/3/asyncio/coroutines.html">PYMOTW writeup on <code class="language-plaintext highlighter-rouge">asyncio</code></a>. Lastly, there’s David Beazley’s <a href="http://www.dabeaz.com/coroutines/">Curious Course on Coroutines and Concurrency</a>, which dives deep into the mechanism by which coroutines run.</p><p>Let’s try to condense all of the above articles into a few sentences: there is a particularly unconventional mechanism by which these coroutines actually get run. Their result is an attribute of the exception object that gets thrown when their <code class="language-plaintext highlighter-rouge">.send()</code> method is called. There’s some more wonky detail to all of this, but it probably won’t help you use this part of the language in practice, so let’s move on for now.</p><p>To tie things together, here are some key points on the topic of coroutines as generators:</p><ul><li>Coroutines are <a href="https://www.python.org/dev/peps/pep-0492/#differences-from-generators">repurposed generators</a> that take advantage of the peculiarities of generator methods.<li>Old generator-based coroutines use <code class="language-plaintext highlighter-rouge">yield from</code> to wait for a coroutine result. Modern Python syntax in native coroutines simply replaces <code class="language-plaintext highlighter-rouge">yield from</code> with <code class="language-plaintext highlighter-rouge">await</code> as the means of waiting on a coroutine result. The <code class="language-plaintext highlighter-rouge">await</code> is analogous to <code class="language-plaintext highlighter-rouge">yield from</code>, and it often helps to think of it as such.<li>The use of <code class="language-plaintext highlighter-rouge">await</code> is a signal that marks a break point. It lets a coroutine temporarily suspend execution and permits the program to come back to it later.</ul><h3 id="other-features-async-for-and-async-generators--comprehensions"><span class="mr-2">Other Features: <code class="language-plaintext highlighter-rouge"><span class="mr-2">async for</code> and Async Generators + Comprehensions</span><a href="#other-features-async-for-and-async-generators--comprehensions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Along with plain <code class="language-plaintext highlighter-rouge">async</code>/<code class="language-plaintext highlighter-rouge">await</code>, Python also enables <code class="language-plaintext highlighter-rouge">async for</code> to iterate over an <strong>asynchronous iterator</strong>. The purpose of an asynchronous iterator is for it to be able to call asynchronous code at each stage when it is iterated over.</p><p>A natural extension of this concept is an <strong>asynchronous generator</strong>. Recall that you can use <code class="language-plaintext highlighter-rouge">await</code>, <code class="language-plaintext highlighter-rouge">return</code>, or <code class="language-plaintext highlighter-rouge">yield</code> in a native coroutine. Using <code class="language-plaintext highlighter-rouge">yield</code> within a coroutine became possible in Python 3.6 (via PEP 525), which introduced asynchronous generators with the purpose of allowing <code class="language-plaintext highlighter-rouge">await</code> and <code class="language-plaintext highlighter-rouge">yield</code> to be used in the same coroutine function body:</p><pre><code class="language-idl">&gt;&gt;&gt; async def mygen(u: int = 10):
...     """Yield powers of 2."""
...     i = 0
...     while i &lt; u:
...         yield 2 ** i
...         i += 1
...         await asyncio.sleep(0.1)
</code></pre><p>Last but not least, Python enables <strong>asynchronous comprehension</strong> with <code class="language-plaintext highlighter-rouge">async for</code>. Like its synchronous cousin, this is largely syntactic sugar:</p><pre><code class="language-idl">&gt;&gt;&gt; async def main():
...     # This does *not* introduce concurrent execution
...     # It is meant to show syntax only
...     g = [i async for i in mygen()]
...     f = [j async for j in mygen() if not (j // 3 % 5)]
...     return g, f
...
&gt;&gt;&gt; g, f = asyncio.run(main())
&gt;&gt;&gt; g
[1, 2, 4, 8, 16, 32, 64, 128, 256, 512]
&gt;&gt;&gt; f
[1, 2, 16, 32, 256, 512]
</code></pre><p>This is a crucial distinction: <strong>neither asynchronous generators nor comprehensions make the iteration concurrent</strong>. All that they do is provide the look-and-feel of their synchronous counterparts, but with the ability for the loop in question to give up control to the event loop for some other coroutine to run.</p><p>In other words, asynchronous iterators and asynchronous generators are not designed to concurrently map some function over a sequence or iterator. They’re merely designed to let the enclosing coroutine allow other tasks to take their turn. The <code class="language-plaintext highlighter-rouge">async for</code> and <code class="language-plaintext highlighter-rouge">async with</code> statements are only needed to the extent that using plain <code class="language-plaintext highlighter-rouge">for</code> or <code class="language-plaintext highlighter-rouge">with</code> would “break” the nature of <code class="language-plaintext highlighter-rouge">await</code> in the coroutine. This distinction between asynchronicity and concurrency is a key one to grasp.</p><h3 id="the-event-loop-and-asynciorun"><span class="mr-2">The Event Loop and <code class="language-plaintext highlighter-rouge"><span class="mr-2">asyncio.run()</code></span><a href="#the-event-loop-and-asynciorun" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>You can think of an event loop as something like a <code class="language-plaintext highlighter-rouge">while True</code> loop that monitors coroutines, taking feedback on what’s idle, and looking around for things that can be executed in the meantime. It is able to wake up an idle coroutine when whatever that coroutine is waiting on becomes available.</p><p>Thus far, the entire management of the event loop has been implicitly handled by one function call:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">asyncio</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>  <span class="c1"># Python 3.7+
</span></pre></table></code></div></div><p><a href="https://github.com/python/cpython/blob/d4c76d960b8b286b75c933780416ace9cda682fd/Lib/asyncio/runners.py#L8"><code class="language-plaintext highlighter-rouge">asyncio.run()</code></a>, introduced in Python 3.7, is responsible for getting the event loop, running tasks until they are marked as complete, and then closing the event loop.</p><p>There’s a more long-winded way of managing the <code class="language-plaintext highlighter-rouge">asyncio</code> event loop, with <code class="language-plaintext highlighter-rouge">get_event_loop()</code>. The typical pattern looks like this:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="p">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
</pre></table></code></div></div><p>You’ll probably see <code class="language-plaintext highlighter-rouge">loop.get_event_loop()</code> floating around in older examples, but unless you have a specific need to fine-tune control over the event loop management, <code class="language-plaintext highlighter-rouge">asyncio.run()</code> should be sufficient for most programs.</p><p>If you do need to interact with the event loop within a Python program, <code class="language-plaintext highlighter-rouge">loop</code> is a good-old-fashioned Python object that supports introspection with <code class="language-plaintext highlighter-rouge">loop.is_running()</code> and <code class="language-plaintext highlighter-rouge">loop.is_closed()</code>. You can manipulate it if you need to get more fine-tuned control, such as in <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio-example-lowlevel-helloworld">scheduling a callback</a> by passing the loop as an argument.</p><p>What is more crucial is understanding a bit beneath the surface about the mechanics of the event loop. Here are a few points worth stressing about the event loop.</p><p><strong>#1:</strong> Coroutines don’t do much on their own until they are tied to the event loop.</p><p>You saw this point before in the explanation on generators, but it’s worth restating. If you have a main coroutine that awaits others, simply calling it in isolation has little effect:</p><pre><code class="language-idl">&gt;&gt;&gt; import asyncio

&gt;&gt;&gt; async def main():
...     print("Hello ...")
...     await asyncio.sleep(1)
...     print("World!")

&gt;&gt;&gt; routine = main()
&gt;&gt;&gt; routine
&lt;coroutine object main at 0x1027a6150&gt;
</code></pre><p>Remember to use <code class="language-plaintext highlighter-rouge">asyncio.run()</code> to actually force execution by scheduling the <code class="language-plaintext highlighter-rouge">main()</code> coroutine (future object) for execution on the event loop:</p><pre><code class="language-idl">&gt;&gt;&gt; asyncio.run(routine)
Hello ...
World!
</code></pre><p>(Other coroutines can be executed with <code class="language-plaintext highlighter-rouge">await</code>. It is typical to wrap just <code class="language-plaintext highlighter-rouge">main()</code> in <code class="language-plaintext highlighter-rouge">asyncio.run()</code>, and chained coroutines with <code class="language-plaintext highlighter-rouge">await</code> will be called from there.)</p><p><strong>#2:</strong> By default, an async IO event loop runs in a single thread and on a single CPU core. Usually, running one single-threaded event loop in one CPU core is more than sufficient. It is also possible to run event loops across multiple cores. Check out this <a href="https://youtu.be/0kXaLh8Fz3k?t=10m30s">talk by John Reese</a> for more, and be warned that your laptop may spontaneously combust.</p><p><strong>#3.</strong> Event loops are pluggable. That is, you could, if you really wanted, write your own event loop implementation and have it run tasks just the same. This is wonderfully demonstrated in the <a href="https://github.com/MagicStack/uvloop"><code class="language-plaintext highlighter-rouge">uvloop</code></a> package, which is an implementation of the event loop in Cython.</p><p>That is what is meant by the term “pluggable event loop”: you can use any working implementation of an event loop, unrelated to the structure of the coroutines themselves. The <code class="language-plaintext highlighter-rouge">asyncio</code> package itself ships with <a href="https://docs.python.org/3/library/asyncio-eventloop.html#event-loop-implementations">two different event loop implementations</a>, with the default being based on the <a href="https://docs.python.org/3/library/selectors.html#module-selectors"><code class="language-plaintext highlighter-rouge">selectors</code></a> module. (The second implementation is built for Windows only.)</p><h2 id="a-full-program-asynchronous-requests"><span class="mr-2">A Full Program: Asynchronous Requests</span><a href="#a-full-program-asynchronous-requests" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>You’ve made it this far, and now it’s time for the fun and painless part. In this section, you’ll build a web-scraping URL collector, <code class="language-plaintext highlighter-rouge">areq.py</code>, using <code class="language-plaintext highlighter-rouge">aiohttp</code>, a blazingly fast async HTTP client/server framework. (We just need the client part.) Such a tool could be used to map connections between a cluster of sites, with the links forming a <a href="https://en.wikipedia.org/wiki/Directed_graph">directed graph</a>.</p><blockquote><p><strong>Note</strong>: You may be wondering why Python’s <code class="language-plaintext highlighter-rouge">requests</code> package isn’t compatible with async IO. <code class="language-plaintext highlighter-rouge">requests</code> is built on top of <code class="language-plaintext highlighter-rouge">urllib3</code>, which in turn uses Python’s <code class="language-plaintext highlighter-rouge">http</code> and <code class="language-plaintext highlighter-rouge">socket</code> modules.</p><p>By default, socket operations are blocking. This means that Python won’t like <code class="language-plaintext highlighter-rouge">await requests.get(url)</code> because <code class="language-plaintext highlighter-rouge">.get()</code> is not awaitable. In contrast, almost everything in <code class="language-plaintext highlighter-rouge">aiohttp</code> is an awaitable coroutine, such as <a href="https://github.com/aio-libs/aiohttp/blob/508adbb656da2e9ae660da5e98e1e5fa6669a3f4/aiohttp/client.py#L225"><code class="language-plaintext highlighter-rouge">session.request()</code></a> and <a href="https://github.com/aio-libs/aiohttp/blob/da75122f6089a250128d2736f2bd88d10e97ca17/aiohttp/client_reqrep.py#L913"><code class="language-plaintext highlighter-rouge">response.text()</code></a>. It’s a great package otherwise, but you’re doing yourself a disservice by using <code class="language-plaintext highlighter-rouge">requests</code> in asynchronous code.</p></blockquote><p>The high-level program structure will look like this:</p><ol><li>Read a sequence of URLs from a local file, <code class="language-plaintext highlighter-rouge">urls.txt</code>.<li>Send GET requests for the URLs and decode the resulting content. If this fails, stop there for a URL.<li>Search for the URLs within <code class="language-plaintext highlighter-rouge">href</code> tags in the HTML of the responses.<li>Write the results to <code class="language-plaintext highlighter-rouge">foundurls.txt</code>.<li>Do all of the above as asynchronously and concurrently as possible. (Use <code class="language-plaintext highlighter-rouge">aiohttp</code> for the requests, and <code class="language-plaintext highlighter-rouge">aiofiles</code> for the file-appends. These are two primary examples of IO that are well-suited for the async IO model.)</ol><p>Here are the contents of <code class="language-plaintext highlighter-rouge">urls.txt</code>. It’s not huge, and contains mostly highly trafficked sites:</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">cat </span>urls.txt
https://regex101.com/
https://docs.python.org/3/this-url-will-404.html
https://www.nytimes.com/guides/
https://www.mediamatters.org/
https://1.1.1.1/
https://www.politico.com/tipsheets/morning-money
https://www.bloomberg.com/markets/economics
https://www.ietf.org/rfc/rfc2616.txt
</pre></table></code></div></div><p>The second URL in the list should return a 404 response, which you’ll need to handle gracefully. If you’re running an expanded version of this program, you’ll probably need to deal with much hairier problems than this, such a server disconnections and endless redirects.</p><p>The requests themselves should be made using a single session, to take advantage of reusage of the session’s internal connection pool.</p><p>Let’s take a look at the full program. We’ll walk through things step-by-step after:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
</pre><td class="rouge-code"><pre><span class="c1">#!/usr/bin/env python3
# areq.py
</span>
<span class="s">"""Asynchronously get links embedded in multiple pages' HMTL."""</span>

<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">IO</span>
<span class="kn">import</span> <span class="nn">urllib.error</span>
<span class="kn">import</span> <span class="nn">urllib.parse</span>

<span class="kn">import</span> <span class="nn">aiofiles</span>
<span class="kn">import</span> <span class="nn">aiohttp</span>
<span class="kn">from</span> <span class="nn">aiohttp</span> <span class="kn">import</span> <span class="n">ClientSession</span>

<span class="n">logging</span><span class="p">.</span><span class="n">basicConfig</span><span class="p">(</span>
    <span class="nb">format</span><span class="o">=</span><span class="s">"%(asctime)s %(levelname)s:%(name)s: %(message)s"</span><span class="p">,</span>
    <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="p">.</span><span class="n">DEBUG</span><span class="p">,</span>
    <span class="n">datefmt</span><span class="o">=</span><span class="s">"%H:%M:%S"</span><span class="p">,</span>
    <span class="n">stream</span><span class="o">=</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="p">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s">"areq"</span><span class="p">)</span>
<span class="n">logging</span><span class="p">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s">"chardet.charsetprober"</span><span class="p">).</span><span class="n">disabled</span> <span class="o">=</span> <span class="bp">True</span>

<span class="n">HREF_RE</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="nb">compile</span><span class="p">(</span><span class="sa">r</span><span class="s">'href="(.*?)"'</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">fetch_html</span><span class="p">(</span><span class="n">url</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">session</span><span class="p">:</span> <span class="n">ClientSession</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="s">"""GET request wrapper to fetch page HTML.

    kwargs are passed to `session.request()`.
    """</span>

    <span class="n">resp</span> <span class="o">=</span> <span class="k">await</span> <span class="n">session</span><span class="p">.</span><span class="n">request</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s">"GET"</span><span class="p">,</span> <span class="n">url</span><span class="o">=</span><span class="n">url</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">resp</span><span class="p">.</span><span class="n">raise_for_status</span><span class="p">()</span>
    <span class="n">logger</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Got response [%s] for URL: %s"</span><span class="p">,</span> <span class="n">resp</span><span class="p">.</span><span class="n">status</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span>
    <span class="n">html</span> <span class="o">=</span> <span class="k">await</span> <span class="n">resp</span><span class="p">.</span><span class="n">text</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">html</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">url</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">session</span><span class="p">:</span> <span class="n">ClientSession</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
    <span class="s">"""Find HREFs in the HTML of `url`."""</span>
    <span class="n">found</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">html</span> <span class="o">=</span> <span class="k">await</span> <span class="n">fetch_html</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="n">url</span><span class="p">,</span> <span class="n">session</span><span class="o">=</span><span class="n">session</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span>
        <span class="n">aiohttp</span><span class="p">.</span><span class="n">ClientError</span><span class="p">,</span>
        <span class="n">aiohttp</span><span class="p">.</span><span class="n">http_exceptions</span><span class="p">.</span><span class="n">HttpProcessingError</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">logger</span><span class="p">.</span><span class="n">error</span><span class="p">(</span>
            <span class="s">"aiohttp exception for %s [%s]: %s"</span><span class="p">,</span>
            <span class="n">url</span><span class="p">,</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="s">"status"</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="s">"message"</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">found</span>
    <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">logger</span><span class="p">.</span><span class="n">exception</span><span class="p">(</span>
            <span class="s">"Non-aiohttp exception occured:  %s"</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="s">"__dict__"</span><span class="p">,</span> <span class="p">{})</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">found</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">HREF_RE</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="n">html</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">abslink</span> <span class="o">=</span> <span class="n">urllib</span><span class="p">.</span><span class="n">parse</span><span class="p">.</span><span class="n">urljoin</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="n">urllib</span><span class="p">.</span><span class="n">error</span><span class="p">.</span><span class="n">URLError</span><span class="p">,</span> <span class="nb">ValueError</span><span class="p">):</span>
                <span class="n">logger</span><span class="p">.</span><span class="n">exception</span><span class="p">(</span><span class="s">"Error parsing URL: %s"</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">found</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">abslink</span><span class="p">)</span>
        <span class="n">logger</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Found %d links for %s"</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">found</span><span class="p">),</span> <span class="n">url</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">found</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">write_one</span><span class="p">(</span><span class="nb">file</span><span class="p">:</span> <span class="n">IO</span><span class="p">,</span> <span class="n">url</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="s">"""Write the found HREFs from `url` to `file`."""</span>
    <span class="n">res</span> <span class="o">=</span> <span class="k">await</span> <span class="n">parse</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="n">url</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">res</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">aiofiles</span><span class="p">.</span><span class="nb">open</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="s">"a"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
            <span class="k">await</span> <span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">url</span><span class="si">}</span><span class="se">\t</span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
        <span class="n">logger</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Wrote results for source URL: %s"</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">bulk_crawl_and_write</span><span class="p">(</span><span class="nb">file</span><span class="p">:</span> <span class="n">IO</span><span class="p">,</span> <span class="n">urls</span><span class="p">:</span> <span class="nb">set</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="s">"""Crawl &amp; write concurrently to `file` for multiple `urls`."""</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">ClientSession</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="n">tasks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls</span><span class="p">:</span>
            <span class="n">tasks</span><span class="p">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">write_one</span><span class="p">(</span><span class="nb">file</span><span class="o">=</span><span class="nb">file</span><span class="p">,</span> <span class="n">url</span><span class="o">=</span><span class="n">url</span><span class="p">,</span> <span class="n">session</span><span class="o">=</span><span class="n">session</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pathlib</span>
    <span class="kn">import</span> <span class="nn">sys</span>

    <span class="k">assert</span> <span class="n">sys</span><span class="p">.</span><span class="n">version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="s">"Script requires Python 3.7+."</span>
    <span class="n">here</span> <span class="o">=</span> <span class="n">pathlib</span><span class="p">.</span><span class="n">Path</span><span class="p">(</span><span class="n">__file__</span><span class="p">).</span><span class="n">parent</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">here</span><span class="p">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s">"urls.txt"</span><span class="p">))</span> <span class="k">as</span> <span class="n">infile</span><span class="p">:</span>
        <span class="n">urls</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">.</span><span class="n">strip</span><span class="p">,</span> <span class="n">infile</span><span class="p">))</span>

    <span class="n">outpath</span> <span class="o">=</span> <span class="n">here</span><span class="p">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s">"foundurls.txt"</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">outpath</span><span class="p">,</span> <span class="s">"w"</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
        <span class="n">outfile</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s">"source_url</span><span class="se">\t</span><span class="s">parsed_url</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>

    <span class="n">asyncio</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">bulk_crawl_and_write</span><span class="p">(</span><span class="nb">file</span><span class="o">=</span><span class="n">outpath</span><span class="p">,</span> <span class="n">urls</span><span class="o">=</span><span class="n">urls</span><span class="p">))</span>
</pre></table></code></div></div><p>This script is longer than our initial toy programs, so let’s break it down.</p><p>The constant <code class="language-plaintext highlighter-rouge">HREF_RE</code> is a <a href="https://realpython.com/regex-python/">regular expression</a> to extract what we’re ultimately searching for, <code class="language-plaintext highlighter-rouge">href</code> tags within HTML:</p><pre><code class="language-idl">&gt;&gt;&gt; HREF_RE.search('Go to &lt;a href="https://realpython.com/"&gt;Real Python&lt;/a&gt;')
&lt;re.Match object; span=(15, 45), match='href="https://realpython.com/"'&gt;
</code></pre><p>The coroutine <code class="language-plaintext highlighter-rouge">fetch_html()</code> is a wrapper around a GET request to make the request and decode the resulting page HTML. It makes the request, awaits the response, and raises right away in the case of a non-200 status:</p><pre><code class="language-idl">resp = await session.request(method="GET", url=url, **kwargs)
resp.raise_for_status()
</code></pre><p>If the status is okay, <code class="language-plaintext highlighter-rouge">fetch_html()</code> returns the page HTML (a <code class="language-plaintext highlighter-rouge">str</code>). Notably, there is no exception handling done in this function. The logic is to propagate that exception to the caller and let it be handled there:</p><pre><code class="language-idl">html = await resp.text()
</code></pre><p>We <code class="language-plaintext highlighter-rouge">await</code> <code class="language-plaintext highlighter-rouge">session.request()</code> and <code class="language-plaintext highlighter-rouge">resp.text()</code> because they’re awaitable coroutines. The request/response cycle would otherwise be the long-tailed, time-hogging portion of the application, but with async IO, <code class="language-plaintext highlighter-rouge">fetch_html()</code> lets the event loop work on other readily available jobs such as parsing and writing URLs that have already been fetched.</p><p>Next in the chain of coroutines comes <code class="language-plaintext highlighter-rouge">parse()</code>, which waits on <code class="language-plaintext highlighter-rouge">fetch_html()</code> for a given URL, and then extracts all of the <code class="language-plaintext highlighter-rouge">href</code> tags from that page’s HTML, making sure that each is valid and formatting it as an absolute path.</p><p>Admittedly, the second portion of <code class="language-plaintext highlighter-rouge">parse()</code> is blocking, but it consists of a quick regex match and ensuring that the links discovered are made into absolute paths.</p><p>In this specific case, this synchronous code should be quick and inconspicuous. But just remember that any line within a given coroutine will block other coroutines unless that line uses <code class="language-plaintext highlighter-rouge">yield</code>, <code class="language-plaintext highlighter-rouge">await</code>, or <code class="language-plaintext highlighter-rouge">return</code>. If the parsing was a more intensive process, you might want to consider running this portion in its own process with <a href="https://docs.python.org/3/library/asyncio-eventloop.html#executing-code-in-thread-or-process-pools"><code class="language-plaintext highlighter-rouge">loop.run_in_executor()</code></a>.</p><p>Next, the coroutine <code class="language-plaintext highlighter-rouge">write()</code> takes a file object and a single URL, and waits on <code class="language-plaintext highlighter-rouge">parse()</code> to return a <code class="language-plaintext highlighter-rouge">set</code> of the parsed URLs, writing each to the file asynchronously along with its source URL through use of <code class="language-plaintext highlighter-rouge">aiofiles</code>, a package for async file IO.</p><p>Lastly, <code class="language-plaintext highlighter-rouge">bulk_crawl_and_write()</code> serves as the main entry point into the script’s chain of coroutines. It uses a single session, and a task is created for each URL that is ultimately read from <code class="language-plaintext highlighter-rouge">urls.txt</code>.</p><p>Here are a few additional points that deserve mention:</p><ul><li>The default <code class="language-plaintext highlighter-rouge">ClientSession</code> has an <a href="https://aiohttp.readthedocs.io/en/stable/client_reference.html#connectors">adapter</a> with a maximum of 100 open connections. To change that, pass an instance of <code class="language-plaintext highlighter-rouge">asyncio.connector.TCPConnector</code> to <code class="language-plaintext highlighter-rouge">ClientSession</code>. You can also specify limits on a per-host basis.<li>You can specify max <a href="https://aiohttp.readthedocs.io/en/stable/client_quickstart.html#timeouts">timeouts</a> for both the session as a whole and for individual requests.<li>This script also uses <code class="language-plaintext highlighter-rouge">async with</code>, which works with an <a href="https://www.python.org/dev/peps/pep-0492/#asynchronous-context-managers-and-async-with">asynchronous context manager</a>. I haven’t devoted a whole section to this concept because the transition from synchronous to asynchronous context managers is fairly straightforward. The latter has to define <code class="language-plaintext highlighter-rouge">.__aenter__()</code> and <code class="language-plaintext highlighter-rouge">.__aexit__()</code> rather than <code class="language-plaintext highlighter-rouge">.__exit__()</code> and <code class="language-plaintext highlighter-rouge">.__enter__()</code>. As you might expect, <code class="language-plaintext highlighter-rouge">async with</code> can only be used inside a coroutine function declared with <code class="language-plaintext highlighter-rouge">async def</code>.</ul><p>If you’d like to explore a bit more, the <a href="https://github.com/realpython/materials/tree/master/asyncio-walkthrough">companion files</a> for this tutorial up at GitHub have comments and docstrings attached as well.</p><p>Here’s the execution in all of its glory, as <code class="language-plaintext highlighter-rouge">areq.py</code> gets, parses, and saves results for 9 URLs in under a second:</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="nv">$ </span>python3 areq.py
21:33:22 DEBUG:asyncio: Using selector: KqueueSelector
21:33:22 INFO:areq: Got response <span class="o">[</span>200] <span class="k">for </span>URL: https://www.mediamatters.org/
21:33:22 INFO:areq: Found 115 links <span class="k">for </span>https://www.mediamatters.org/
21:33:22 INFO:areq: Got response <span class="o">[</span>200] <span class="k">for </span>URL: https://www.nytimes.com/guides/
21:33:22 INFO:areq: Got response <span class="o">[</span>200] <span class="k">for </span>URL: https://www.politico.com/tipsheets/morning-money
21:33:22 INFO:areq: Got response <span class="o">[</span>200] <span class="k">for </span>URL: https://www.ietf.org/rfc/rfc2616.txt
21:33:22 ERROR:areq: aiohttp exception <span class="k">for </span>https://docs.python.org/3/this-url-will-404.html <span class="o">[</span>404]: Not Found
21:33:22 INFO:areq: Found 120 links <span class="k">for </span>https://www.nytimes.com/guides/
21:33:22 INFO:areq: Found 143 links <span class="k">for </span>https://www.politico.com/tipsheets/morning-money
21:33:22 INFO:areq: Wrote results <span class="k">for </span><span class="nb">source </span>URL: https://www.mediamatters.org/
21:33:22 INFO:areq: Found 0 links <span class="k">for </span>https://www.ietf.org/rfc/rfc2616.txt
21:33:22 INFO:areq: Got response <span class="o">[</span>200] <span class="k">for </span>URL: https://1.1.1.1/
21:33:22 INFO:areq: Wrote results <span class="k">for </span><span class="nb">source </span>URL: https://www.nytimes.com/guides/
21:33:22 INFO:areq: Wrote results <span class="k">for </span><span class="nb">source </span>URL: https://www.politico.com/tipsheets/morning-money
21:33:22 INFO:areq: Got response <span class="o">[</span>200] <span class="k">for </span>URL: https://www.bloomberg.com/markets/economics
21:33:22 INFO:areq: Found 3 links <span class="k">for </span>https://www.bloomberg.com/markets/economics
21:33:22 INFO:areq: Wrote results <span class="k">for </span><span class="nb">source </span>URL: https://www.bloomberg.com/markets/economics
21:33:23 INFO:areq: Found 36 links <span class="k">for </span>https://1.1.1.1/
21:33:23 INFO:areq: Got response <span class="o">[</span>200] <span class="k">for </span>URL: https://regex101.com/
21:33:23 INFO:areq: Found 23 links <span class="k">for </span>https://regex101.com/
21:33:23 INFO:areq: Wrote results <span class="k">for </span><span class="nb">source </span>URL: https://regex101.com/
21:33:23 INFO:areq: Wrote results <span class="k">for </span><span class="nb">source </span>URL: https://1.1.1.1/
</pre></table></code></div></div><p>That’s not too shabby! As a sanity check, you can check the line-count on the output. In my case, it’s 626, though keep in mind this may fluctuate:</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">wc</span> <span class="nt">-l</span> foundurls.txt
     626 foundurls.txt

<span class="nv">$ </span><span class="nb">head</span> <span class="nt">-n</span> 3 foundurls.txt
source_url  parsed_url
https://www.bloomberg.com/markets/economics https://www.bloomberg.com/feedback
https://www.bloomberg.com/markets/economics https://www.bloomberg.com/notices/tos
</pre></table></code></div></div><blockquote><p><strong>Next Steps</strong>: If you’d like to up the ante, make this webcrawler <a href="https://realpython.com/python-thinking-recursively/">recursive</a>. You can use <a href="https://github.com/aio-libs/aioredis"><code class="language-plaintext highlighter-rouge">aio-redis</code></a> to keep track of which URLs have been crawled within the tree to avoid requesting them twice, and connect links with Python’s <code class="language-plaintext highlighter-rouge">networkx</code> library.</p><p>Remember to be nice. Sending 1000 concurrent requests to a small, unsuspecting website is bad, bad, bad. There are ways to limit how many concurrent requests you’re making in one batch, such as in using the <a href="https://stackoverflow.com/q/40836800/7954504">sempahore</a> objects of <code class="language-plaintext highlighter-rouge">asyncio</code> or using a pattern <a href="https://www.artificialworlds.net/blog/2017/05/31/python-3-large-numbers-of-tasks-with-limited-concurrency/">like this one</a>. If you don’t heed this warning, you may get a massive batch of <code class="language-plaintext highlighter-rouge">TimeoutError</code> exceptions and only end up hurting your own program.</p></blockquote><h2 id="async-io-in-context"><span class="mr-2">Async IO in Context</span><a href="#async-io-in-context" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Now that you’ve seen a healthy dose of code, let’s step back for a minute and consider when async IO is an ideal option and how you can make the comparison to arrive at that conclusion or otherwise choose a different model of concurrency.</p><h3 id="when-and-why-is-async-io-the-right-choice"><span class="mr-2">When and Why Is Async IO the Right Choice?</span><a href="#when-and-why-is-async-io-the-right-choice" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>This tutorial is no place for an extended treatise on async IO versus threading versus multiprocessing. However, it’s useful to have an idea of when async IO is probably the best candidate of the three.</p><p>The battle over async IO versus multiprocessing is not really a battle at all. In fact, they can be <a href="https://youtu.be/0kXaLh8Fz3k?t=10m30s">used in concert</a>. If you have multiple, fairly uniform CPU-bound tasks (a great example is a <a href="http://scikit-learn.org/stable/modules/grid_search.html#parallelism">grid search</a> in libraries such as <code class="language-plaintext highlighter-rouge">scikit-learn</code> or <code class="language-plaintext highlighter-rouge">keras</code>), multiprocessing should be an obvious choice.</p><p>Simply putting <code class="language-plaintext highlighter-rouge">async</code> before every function is a bad idea if all of the functions use blocking calls. (This can actually slow down your code.) But as mentioned previously, there are places where async IO and multiprocessing can <a href="https://youtu.be/0kXaLh8Fz3k?t=10m30s">live in harmony</a>.</p><p>The contest between async IO and threading is a little bit more direct. I mentioned in the introduction that “threading is hard.” The full story is that, even in cases where threading seems easy to implement, it can still lead to infamous impossible-to-trace bugs due to race conditions and memory usage, among other things.</p><p>Threading also tends to scale less elegantly than async IO, because threads are a system resource with a finite availability. Creating thousands of threads will fail on many machines, and I don’t recommend trying it in the first place. Creating thousands of async IO tasks is completely feasible.</p><font color="red">Async IO shines when you have multiple IO-bound tasks where the tasks would otherwise be dominated by blocking IO-bound wait time, such as:</font><ul><li>Network IO, whether your program is the server or the client side<li>Serverless designs, such as a peer-to-peer, multi-user network like a group chatroom<li>Read/write operations where you want to mimic a “fire-and-forget” style but worry less about holding a lock on whatever you’re reading and writing to</ul><p>The biggest reason not to use it is that <code class="language-plaintext highlighter-rouge">await</code> only supports a specific set of objects that define a specific set of methods. If you want to do async read operations with a certain DBMS, you’ll need to find not just a Python wrapper for that DBMS, but one that supports the <code class="language-plaintext highlighter-rouge">async</code>/<code class="language-plaintext highlighter-rouge">await</code> syntax. Coroutines that contain synchronous calls block other coroutines and tasks from running.</p><p>For a shortlist of libraries that work with <code class="language-plaintext highlighter-rouge">async</code>/<code class="language-plaintext highlighter-rouge">await</code>, see the <a href="https://realpython.com/async-io-python/#libraries-that-work-with-asyncawait">list</a> at the end of this tutorial.</p><h3 id="async-io-it-is-but-which-one"><span class="mr-2">Async IO It Is, but Which One?</span><a href="#async-io-it-is-but-which-one" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>This tutorial focuses on async IO, the <code class="language-plaintext highlighter-rouge">async</code>/<code class="language-plaintext highlighter-rouge">await</code> syntax, and using <code class="language-plaintext highlighter-rouge">asyncio</code> for event-loop management and specifying tasks. <code class="language-plaintext highlighter-rouge">asyncio</code> certainly isn’t the only async IO library out there. This observation from Nathaniel J. Smith says a lot:</p><blockquote><p>[In] a few years, <code class="language-plaintext highlighter-rouge">asyncio</code> might find itself relegated to becoming one of those stdlib libraries that savvy developers avoid, like <code class="language-plaintext highlighter-rouge">urllib2</code>.</p><p>…</p><p>What I’m arguing, in effect, is that <code class="language-plaintext highlighter-rouge">asyncio</code> is a victim of its own success: when it was designed, it used the best approach possible; but since then, work inspired by <code class="language-plaintext highlighter-rouge">asyncio</code> – like the addition of <code class="language-plaintext highlighter-rouge">async</code>/<code class="language-plaintext highlighter-rouge">await</code> – has shifted the landscape so that we can do even better, and now <code class="language-plaintext highlighter-rouge">asyncio</code> is hamstrung by its earlier commitments. <a href="https://vorpus.org/blog/some-thoughts-on-asynchronous-api-design-in-a-post-asyncawait-world/">(Source)</a></p></blockquote><p>To that end, a few big-name alternatives that do what <code class="language-plaintext highlighter-rouge">asyncio</code> does, albeit with different APIs and different approaches, are <a href="https://github.com/dabeaz/curio"><code class="language-plaintext highlighter-rouge">curio</code></a> and <a href="https://github.com/python-trio/trio"><code class="language-plaintext highlighter-rouge">trio</code></a>. Personally, I think that if you’re building a moderately sized, straightforward program, just using <code class="language-plaintext highlighter-rouge">asyncio</code> is plenty sufficient and understandable, and lets you avoid adding yet another large dependency outside of Python’s standard library.</p><p>But by all means, check out <code class="language-plaintext highlighter-rouge">curio</code> and <code class="language-plaintext highlighter-rouge">trio</code>, and you might find that they get the same thing done in a way that’s more intuitive for you as the user. Many of the package-agnostic concepts presented here should permeate to alternative async IO packages as well.</p><h2 id="odds-and-ends"><span class="mr-2">Odds and Ends</span><a href="#odds-and-ends" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>In these next few sections, you’ll cover some miscellaneous parts of <code class="language-plaintext highlighter-rouge">asyncio</code> and <code class="language-plaintext highlighter-rouge">async</code>/<code class="language-plaintext highlighter-rouge">await</code> that haven’t fit neatly into the tutorial thus far, but are still important for building and understanding a full program.</p><h3 id="other-top-level-asyncio-functions"><span class="mr-2">Other Top-Level <code class="language-plaintext highlighter-rouge"><span class="mr-2">asyncio</code> Functions</span><a href="#other-top-level-asyncio-functions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>In addition to <code class="language-plaintext highlighter-rouge">asyncio.run()</code>, you’ve seen a few other package-level functions such as <code class="language-plaintext highlighter-rouge">asyncio.create_task()</code> and <code class="language-plaintext highlighter-rouge">asyncio.gather()</code>.</p><p>You can use <code class="language-plaintext highlighter-rouge">create_task()</code> to schedule the execution of a coroutine object, followed by <code class="language-plaintext highlighter-rouge">asyncio.run()</code>:</p><pre><code class="language-idl">&gt;&gt;&gt; import asyncio

&gt;&gt;&gt; async def coro(seq) -&gt; list:
...     """'IO' wait time is proportional to the max element."""
...     await asyncio.sleep(max(seq))
...     return list(reversed(seq))
...
&gt;&gt;&gt; async def main():
...     # This is a bit redundant in the case of one task
...     # We could use `await coro([3, 2, 1])` on its own
...     t = asyncio.create_task(coro([3, 2, 1]))  # Python 3.7+
...     await t
...     print(f't: type {type(t)}')
...     print(f't done: {t.done()}')
...
&gt;&gt;&gt; t = asyncio.run(main())
t: type &lt;class '_asyncio.Task'&gt;
t done: True
</code></pre><p>There’s a subtlety to this pattern: if you don’t <code class="language-plaintext highlighter-rouge">await t</code> within <code class="language-plaintext highlighter-rouge">main()</code>, it may finish before <code class="language-plaintext highlighter-rouge">main()</code> itself signals that it is complete. Because <code class="language-plaintext highlighter-rouge">asyncio.run(main())</code> <a href="https://github.com/python/cpython/blob/7e18deef652a9d413d5dbd19d61073ba7eb5460e/Lib/asyncio/runners.py#L43">calls <code class="language-plaintext highlighter-rouge">loop.run_until_complete(main())</code></a>, the event loop is only concerned (without <code class="language-plaintext highlighter-rouge">await t</code> present) that <code class="language-plaintext highlighter-rouge">main()</code> is done, not that the tasks that get created within <code class="language-plaintext highlighter-rouge">main()</code> are done. Without <code class="language-plaintext highlighter-rouge">await t</code>, the loop’s other tasks <a href="https://github.com/python/cpython/blob/7e18deef652a9d413d5dbd19d61073ba7eb5460e/Lib/asyncio/runners.py#L46">will be cancelled</a>, possibly before they are completed. If you need to get a list of currently pending tasks, you can use <code class="language-plaintext highlighter-rouge">asyncio.Task.all_tasks()</code>.</p><p><strong>Note</strong>: <code class="language-plaintext highlighter-rouge">asyncio.create_task()</code> was introduced in Python 3.7. In Python 3.6 or lower, use <code class="language-plaintext highlighter-rouge">asyncio.ensure_future()</code> in place of <code class="language-plaintext highlighter-rouge">create_task()</code>.</p><p>Separately, there’s <code class="language-plaintext highlighter-rouge">asyncio.gather()</code>. While it doesn’t do anything tremendously special, <code class="language-plaintext highlighter-rouge">gather()</code> is meant to neatly put a collection of coroutines (futures) into a single future. As a result, it returns a single future object, and, if you <code class="language-plaintext highlighter-rouge">await asyncio.gather()</code> and specify multiple tasks or coroutines, you’re waiting for all of them to be completed. (This somewhat parallels <code class="language-plaintext highlighter-rouge">queue.join()</code> from our earlier example.) The result of <code class="language-plaintext highlighter-rouge">gather()</code> will be a list of the results across the inputs:</p><pre><code class="language-idl">&gt;&gt;&gt; import time
&gt;&gt;&gt; async def main():
...     t = asyncio.create_task(coro([3, 2, 1]))
...     t2 = asyncio.create_task(coro([10, 5, 0]))  # Python 3.7+
...     print('Start:', time.strftime('%X'))
...     a = await asyncio.gather(t, t2)
...     print('End:', time.strftime('%X'))  # Should be 10 seconds
...     print(f'Both tasks done: {all((t.done(), t2.done()))}')
...     return a
...
&gt;&gt;&gt; a = asyncio.run(main())
Start: 16:20:11
End: 16:20:21
Both tasks done: True
&gt;&gt;&gt; a
[[1, 2, 3], [0, 5, 10]]
</code></pre><p>You probably noticed that <code class="language-plaintext highlighter-rouge">gather()</code> waits on the entire result set of the Futures or coroutines that you pass it. Alternatively, you can loop over <code class="language-plaintext highlighter-rouge">asyncio.as_completed()</code> to get tasks as they are completed, in the order of completion. The function returns an iterator that yields tasks as they finish. Below, the result of <code class="language-plaintext highlighter-rouge">coro([3, 2, 1])</code> will be available before <code class="language-plaintext highlighter-rouge">coro([10, 5, 0])</code> is complete, which is not the case with <code class="language-plaintext highlighter-rouge">gather()</code>:</p><pre><code class="language-idl">&gt;&gt;&gt; async def main():
...     t = asyncio.create_task(coro([3, 2, 1]))
...     t2 = asyncio.create_task(coro([10, 5, 0]))
...     print('Start:', time.strftime('%X'))
...     for res in asyncio.as_completed((t, t2)):
...         compl = await res
...         print(f'res: {compl} completed at {time.strftime("%X")}')
...     print('End:', time.strftime('%X'))
...     print(f'Both tasks done: {all((t.done(), t2.done()))}')
...
&gt;&gt;&gt; a = asyncio.run(main())
Start: 09:49:07
res: [1, 2, 3] completed at 09:49:10
res: [0, 5, 10] completed at 09:49:17
End: 09:49:17
Both tasks done: True
</code></pre><p>Lastly, you may also see <code class="language-plaintext highlighter-rouge">asyncio.ensure_future()</code>. You should rarely need it, because it’s a lower-level plumbing API and largely replaced by <code class="language-plaintext highlighter-rouge">create_task()</code>, which was introduced later.</p><h3 id="the-precedence-of-await"><span class="mr-2">The Precedence of <code class="language-plaintext highlighter-rouge"><span class="mr-2">await</code></span><a href="#the-precedence-of-await" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>While they behave somewhat similarly, the <code class="language-plaintext highlighter-rouge">await</code> keyword has significantly higher precedence than <code class="language-plaintext highlighter-rouge">yield</code>. This means that, because it is more tightly bound, there are a number of instances where you’d need parentheses in a <code class="language-plaintext highlighter-rouge">yield from</code> statement that are not required in an analogous <code class="language-plaintext highlighter-rouge">await</code> statement. For more information, see <a href="https://www.python.org/dev/peps/pep-0492/#examples-of-await-expressions">examples of <code class="language-plaintext highlighter-rouge">await</code> expressions</a> from PEP 492.</p><h2 id="conclusion"><span class="mr-2">Conclusion</span><a href="#conclusion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>You’re now equipped to use <code class="language-plaintext highlighter-rouge">async</code>/<code class="language-plaintext highlighter-rouge">await</code> and the libraries built off of it. Here’s a recap of what you’ve covered:</p><ul><li>Asynchronous IO as a language-agnostic model and a way to effect concurrency by letting coroutines indirectly communicate with each other<li>The specifics of Python’s new <code class="language-plaintext highlighter-rouge">async</code> and <code class="language-plaintext highlighter-rouge">await</code> keywords, used to mark and define coroutines<li><code class="language-plaintext highlighter-rouge">asyncio</code>, the Python package that provides the API to run and manage coroutines</ul><h2 id="resources"><span class="mr-2">Resources</span><a href="#resources" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="python-version-specifics"><span class="mr-2">Python Version Specifics</span><a href="#python-version-specifics" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Async IO in Python has evolved swiftly, and it can be hard to keep track of what came when. Here’s a list of Python minor-version changes and introductions related to <code class="language-plaintext highlighter-rouge">asyncio</code>:</p><ul><li>3.3: The <code class="language-plaintext highlighter-rouge">yield from</code> expression allows for generator delegation.<li>3.4: <code class="language-plaintext highlighter-rouge">asyncio</code> was introduced in the Python standard library with provisional API status.<li>3.5: <code class="language-plaintext highlighter-rouge">async</code> and <code class="language-plaintext highlighter-rouge">await</code> became a part of the Python grammar, used to signify and wait on coroutines. They were not yet reserved keywords. (You could still define functions or variables named <code class="language-plaintext highlighter-rouge">async</code> and <code class="language-plaintext highlighter-rouge">await</code>.)<li>3.6: Asynchronous generators and asynchronous comprehensions were introduced. The API of <code class="language-plaintext highlighter-rouge">asyncio</code> was declared stable rather than provisional.<li>3.7: <code class="language-plaintext highlighter-rouge">async</code> and <code class="language-plaintext highlighter-rouge">await</code> became reserved keywords. (They cannot be used as identifiers.) They are intended to replace the <code class="language-plaintext highlighter-rouge">asyncio.coroutine()</code> decorator. <code class="language-plaintext highlighter-rouge">asyncio.run()</code> was introduced to the <code class="language-plaintext highlighter-rouge">asyncio</code> package, among <a href="https://docs.python.org/3/whatsnew/3.7.html#whatsnew37-asyncio">a bunch of other features</a>.</ul><p>If you want to be safe (and be able to use <code class="language-plaintext highlighter-rouge">asyncio.run()</code>), go with Python 3.7 or above to get the full set of features.</p><h3 id="articles"><span class="mr-2">Articles</span><a href="#articles" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Here’s a curated list of additional resources:</p><ul><li>Real Python: <a href="https://realpython.com/python-concurrency/">Speed up your Python Program with Concurrency</a><li>Real Python: <a href="https://realpython.com/python-gil/">What is the Python Global Interpreter Lock?</a><li>CPython: The <code class="language-plaintext highlighter-rouge">asyncio</code> package <a href="https://github.com/python/cpython/tree/master/Lib/asyncio">source</a><li>Python docs: <a href="https://docs.python.org/3/reference/datamodel.html#coroutines">Data model &gt; Coroutines</a><li>TalkPython: <a href="https://training.talkpython.fm/courses/details/async-in-python-with-threading-and-multiprocessing">Async Techniques and Examples in Python</a><li>Brett Cannon: <a href="https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/">How the Heck Does Async-Await Work in Python 3.5?</a><li>PYMOTW: <a href="https://pymotw.com/3/asyncio/"><code class="language-plaintext highlighter-rouge">asyncio</code></a><li>A. Jesse Jiryu Davis and Guido van Rossum: <a href="http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html">A Web Crawler With asyncio Coroutines</a><li>Andy Pearce: <a href="http://www.andy-pearce.com/blog/posts/2016/Jun/the-state-of-python-coroutines-yield-from/">The State of Python Coroutines: <code class="language-plaintext highlighter-rouge">yield from</code></a><li>Nathaniel J. Smith: <a href="https://vorpus.org/blog/some-thoughts-on-asynchronous-api-design-in-a-post-asyncawait-world/">Some Thoughts on Asynchronous API Design in a Post-<code class="language-plaintext highlighter-rouge">async</code>/<code class="language-plaintext highlighter-rouge">await</code> World</a><li>Armin Ronacher: <a href="http://lucumr.pocoo.org/2016/10/30/i-dont-understand-asyncio/">I don’t understand Python’s Asyncio</a><li>Andy Balaam: <a href="http://www.artificialworlds.net/blog/2017/05/31/basic-ideas-of-python-3-asyncio-concurrency/">series on <code class="language-plaintext highlighter-rouge">asyncio</code></a> (4 posts)<li>Stack Overflow: <a href="https://stackoverflow.com/q/40836800/7954504">Python <code class="language-plaintext highlighter-rouge">asyncio.semaphore</code> in <code class="language-plaintext highlighter-rouge">async</code>-<code class="language-plaintext highlighter-rouge">await</code> function</a><li>Yeray Diaz:<ul><li><a href="https://hackernoon.com/asyncio-for-the-working-python-developer-5c468e6e2e8e">AsyncIO for the Working Python Developer</a><li><a href="https://medium.com/python-pandemonium/asyncio-coroutine-patterns-beyond-await-a6121486656f">Asyncio Coroutine Patterns: Beyond <code class="language-plaintext highlighter-rouge">await</code></a></ul></ul><p>A few Python <em>What’s New</em> sections explain the motivation behind language changes in more detail:</p><ul><li><a href="https://docs.python.org/3/whatsnew/3.3.html#pep-380">What’s New in Python 3.3</a> (<code class="language-plaintext highlighter-rouge">yield from</code> and PEP 380)<li><a href="https://docs.python.org/3/whatsnew/3.6.html#whatsnew36-pep525">What’s New in Python 3.6</a> (PEP 525 &amp; 530)</ul><p>From David Beazley:</p><ul><li><a href="http://www.dabeaz.com/generators/">Generator: Tricks for Systems Programmers</a><li><a href="http://www.dabeaz.com/coroutines/">A Curious Course on Coroutines and Concurrency</a><li><a href="http://dabeaz.com/finalgenerator/index.html">Generators: The Final Frontier</a></ul><p>YouTube talks:</p><ul><li><a href="https://youtu.be/0kXaLh8Fz3k">John Reese - Thinking Outside the GIL with AsyncIO and Multiprocessing - PyCon 2018</a><li><a href="https://youtu.be/ZzfHjytDceU">Keynote David Beazley - Topics of Interest (Python Asyncio)</a><li><a href="https://youtu.be/MCs5OvhV9S4">David Beazley - Python Concurrency From the Ground Up: LIVE! - PyCon 2015</a><li><a href="https://youtu.be/9zinZmE3Ogk">Raymond Hettinger, Keynote on Concurrency, PyBay 2017</a><li><a href="https://youtu.be/Bv25Dwe84g0">Thinking about Concurrency, Raymond Hettinger, Python core developer</a><li><a href="https://youtu.be/iG6fr81xHKA">Miguel Grinberg Asynchronous Python for the Complete Beginner PyCon 2017</a><li><a href="https://youtu.be/2ZFFv-wZ8_g">Yury Selivanov asyncawait and asyncio in Python 3 6 and beyond PyCon 2017</a><li><a href="https://youtu.be/E-1Y4kSsAFc">Fear and Awaiting in Async: A Savage Journey to the Heart of the Coroutine Dream</a><li><a href="https://youtu.be/kdzL3r-yJZY">What Is Async, How Does It Work, and When Should I Use It? (PyCon APAC 2014)</a></ul><h3 id="related-peps"><span class="mr-2">Related PEPs</span><a href="#related-peps" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="table-wrapper"><table><thead><tr><th>PEP<th>Date Created<tbody><tr><td><a href="https://www.python.org/dev/peps/pep-0342/">PEP 342 – Coroutines via Enhanced Generators</a><td>2005-05<tr><td><a href="https://www.python.org/dev/peps/pep-0380/">PEP 380 – Syntax for Delegating to a Subgenerator</a><td>2009-02<tr><td><a href="https://www.python.org/dev/peps/pep-3153/">PEP 3153 – Asynchronous IO support</a><td>2011-05<tr><td><a href="https://www.python.org/dev/peps/pep-3156/">PEP 3156 – Asynchronous IO Support Rebooted: the “asyncio” Module</a><td>2012-12<tr><td><a href="https://www.python.org/dev/peps/pep-0492/">PEP 492 – Coroutines with async and await syntax</a><td>2015-04<tr><td><a href="https://www.python.org/dev/peps/pep-0525/">PEP 525 – Asynchronous Generators</a><td>2016-07<tr><td><a href="https://www.python.org/dev/peps/pep-0530/">PEP 530 – Asynchronous Comprehensions</a><td>2016-09</table></div><h3 id="libraries-that-work-with-asyncawait"><span class="mr-2">Libraries That Work With <code class="language-plaintext highlighter-rouge"><span class="mr-2">async</code>/<code class="language-plaintext highlighter-rouge"><span class="mr-2">await</code></span><a href="#libraries-that-work-with-asyncawait" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>From <a href="https://github.com/aio-libs">aio-libs</a>:</p><ul><li><a href="https://github.com/aio-libs/aiohttp"><code class="language-plaintext highlighter-rouge">aiohttp</code></a>: Asynchronous HTTP client/server framework<li><a href="https://github.com/aio-libs/aioredis"><code class="language-plaintext highlighter-rouge">aioredis</code></a>: Async IO Redis support<li><a href="https://github.com/aio-libs/aiopg"><code class="language-plaintext highlighter-rouge">aiopg</code></a>: Async IO PostgreSQL support<li><a href="https://github.com/aio-libs/aiomcache"><code class="language-plaintext highlighter-rouge">aiomcache</code></a>: Async IO memcached client<li><a href="https://github.com/aio-libs/aiokafka"><code class="language-plaintext highlighter-rouge">aiokafka</code></a>: Async IO Kafka client<li><a href="https://github.com/aio-libs/aiozmq"><code class="language-plaintext highlighter-rouge">aiozmq</code></a>: Async IO ZeroMQ support<li><a href="https://github.com/aio-libs/aiojobs"><code class="language-plaintext highlighter-rouge">aiojobs</code></a>: Jobs scheduler for managing background tasks<li><a href="https://github.com/aio-libs/async_lru"><code class="language-plaintext highlighter-rouge">async_lru</code></a>: Simple <a href="https://realpython.com/lru-cache-python/">LRU cache</a> for async IO</ul><p>From <a href="https://magic.io/">magicstack</a>:</p><ul><li><a href="https://github.com/MagicStack/uvloop"><code class="language-plaintext highlighter-rouge">uvloop</code></a>: Ultra fast async IO event loop<li><a href="https://github.com/MagicStack/asyncpg"><code class="language-plaintext highlighter-rouge">asyncpg</code></a>: (Also very fast) async IO PostgreSQL support</ul><p>From other hosts:</p><ul><li><a href="https://github.com/python-trio/trio"><code class="language-plaintext highlighter-rouge">trio</code></a>: Friendlier <code class="language-plaintext highlighter-rouge">asyncio</code> intended to showcase a radically simpler design<li><a href="https://github.com/Tinche/aiofiles"><code class="language-plaintext highlighter-rouge">aiofiles</code></a>: Async file IO<li><a href="https://github.com/theelous3/asks"><code class="language-plaintext highlighter-rouge">asks</code></a>: Async requests-like http library<li><a href="https://github.com/jonathanslenders/asyncio-redis"><code class="language-plaintext highlighter-rouge">asyncio-redis</code></a>: Async IO Redis support<li><a href="https://github.com/dano/aioprocessing"><code class="language-plaintext highlighter-rouge">aioprocessing</code></a>: Integrates <code class="language-plaintext highlighter-rouge">multiprocessing</code> module with <code class="language-plaintext highlighter-rouge">asyncio</code><li><a href="https://github.com/Scille/umongo"><code class="language-plaintext highlighter-rouge">umongo</code></a>: Async IO MongoDB client<li><a href="https://github.com/alex-sherman/unsync"><code class="language-plaintext highlighter-rouge">unsync</code></a>: Unsynchronize <code class="language-plaintext highlighter-rouge">asyncio</code><li><a href="https://github.com/vxgmichel/aiostream"><code class="language-plaintext highlighter-rouge">aiostream</code></a>: Like <code class="language-plaintext highlighter-rouge">itertools</code>, but async</ul></div><div class="post-tail-wrapper text-muted"><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/python/" class="post-tag no-text-decoration" >Python</a> <a href="/tags/%E8%BD%AC%E8%BD%BD/" class="post-tag no-text-decoration" >转载</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Async+IO+in+Python%3A+A+Complete+Walkthrough+-+SeptemberHX%27s+Blog&url=https%3A%2F%2Fblog.hxgpark.com%2Fposts%2FRepost-Async-IO-in-Python-A-Complete-Walkthrough%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Async+IO+in+Python%3A+A+Complete+Walkthrough+-+SeptemberHX%27s+Blog&u=https%3A%2F%2Fblog.hxgpark.com%2Fposts%2FRepost-Async-IO-in-Python-A-Complete-Walkthrough%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fblog.hxgpark.com%2Fposts%2FRepost-Async-IO-in-Python-A-Complete-Walkthrough%2F&text=%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Async+IO+in+Python%3A+A+Complete+Walkthrough+-+SeptemberHX%27s+Blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/JoplinPluginDevelopment/">Joplin插件开发教程</a><li><a href="/posts/K8sClusterTutorial/">Kubernetes 集群搭建</a><li><a href="/posts/ReadCubePapersAPI/">ReadCube Papers API 记录</a><li><a href="/posts/DiDaWebAPI/">滴答清单网页版 API 记录</a><li><a href="/posts/MathOptimizationModel/">数学优化模型分类</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/">强化学习</a> <a class="post-tag" href="/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/">思维导图</a> <a class="post-tag" href="/tags/python/">Python</a> <a class="post-tag" href="/tags/%E8%BD%AC%E8%BD%BD/">转载</a> <a class="post-tag" href="/tags/%E8%BD%AF%E4%BB%B6/">软件</a> <a class="post-tag" href="/tags/deepin/">Deepin</a> <a class="post-tag" href="/tags/kubernetes/">Kubernetes</a> <a class="post-tag" href="/tags/macos/">MacOS</a> <a class="post-tag" href="/tags/shell/">shell</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Repost-A-Python-Interpreter-Written-in-Python/"><div class="card-body"> <em class="small" data-ts="1626644350" data-df="YYYY-MM-DD" > 2021-07-19 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>【转载】A Python Interpreter Written in Python</h3><div class="text-muted small"><p> 本文为转载。非常有助于理解 Python 解释器的原理等，从此对各种 Python 插件、库等不在迷茫【比如 laike9m/Cyberbrain: Python debugging, redefined. (github.com)】。中文版由 qingyunha 翻译维护，原文地址为 500lines。原作者Allison是Dropbox的工程师，在那里她维护着世界上最大的由Python客...</p></div></div></a></div><div class="card"> <a href="/posts/JoplinPluginDevelopment/"><div class="card-body"> <em class="small" data-ts="1665763200" data-df="YYYY-MM-DD" > 2022-10-15 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Joplin插件开发教程</h3><div class="text-muted small"><p> Joplin 是一个 Markdown 笔记工具，相比于 Obsidian 而言，Joplin 是通过关系型数据库存储所有的笔记、信息等，而 Obsidian 是基于文件的。 技术要求 会写代码，会开发 能够读懂英语，需要阅读官方 API 文档 熟悉 JavaScript 的使用：但不是必须得，使用过其他相似的语言也可以。在开发 Enhancement 插件 之前，我也不太...</p></div></div></a></div><div class="card"> <a href="/posts/GetKnowledge/"><div class="card-body"> <em class="small" data-ts="1661616000" data-df="YYYY-MM-DD" > 2022-08-28 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>知识获取</h3><div class="text-muted small"><p> 在信息爆炸的今天，高效的获取高质量数据能够节省大量时间，同时合理的知识处理能够更好的为个人的工作、学习等打下基础。 知识获取 首先是知识来源的选择，取决于各自的目标，包括但不限于： 微信公众号 InfoQ 的各类 topic：https://www.infoq.cn/topic/ 博客 各论文期刊 其它 不知道有哪些时，多和身边的人沟通即可。 同时，可以看到信...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/RL-MindMap-1/" class="btn btn-outline-primary" prompt="上一篇"><p>强化学习第二版导图（一）：MDP、动态规划及蒙特卡洛法</p></a> <a href="/posts/DiDaWebAPI/" class="btn btn-outline-primary" prompt="下一篇"><p>滴答清单网页版 API 记录</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "SeptemberHX/septemberhx.github.io", "data-repo-id": "R_kgDOG5Oxnw", "data-category": "Announcements", "data-category-id": "DIC_kwDOG5Oxn84COcG0", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "bottom", "data-lang": "zh-CN", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/SeptemberHX">SeptemberHX</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/">强化学习</a> <a class="post-tag" href="/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/">思维导图</a> <a class="post-tag" href="/tags/python/">Python</a> <a class="post-tag" href="/tags/%E8%BD%AC%E8%BD%BD/">转载</a> <a class="post-tag" href="/tags/%E8%BD%AF%E4%BB%B6/">软件</a> <a class="post-tag" href="/tags/deepin/">Deepin</a> <a class="post-tag" href="/tags/kubernetes/">Kubernetes</a> <a class="post-tag" href="/tags/macos/">MacOS</a> <a class="post-tag" href="/tags/shell/">shell</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-5DLXWRC9KQ"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-5DLXWRC9KQ'); }); </script>
